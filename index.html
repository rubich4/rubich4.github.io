<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OPEngine</title>
    <style>
        :root {
            --primary-color: #4a6de5;
            --secondary-color: #2c3e50;
            --accent-color: #e74c3c;
            --text-color: #333;
            --light-bg: #f9f9f9;
            --code-bg: #282c34;
            --overlay-bg: rgba(0, 0, 0, 0.8);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--light-bg);
        }
        
        header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 2rem 0;
            text-align: center;
        }
        
        nav {
            background-color: var(--secondary-color);
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        nav ul {
            display: flex;
            justify-content: center;
            list-style-type: none;
            padding: 0.8rem 0;
        }
        
        nav li {
            margin: 0 1.5rem;
        }
        
        nav a {
            color: white;
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s;
        }
        
        nav a:hover {
            color: var(--accent-color);
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        section {
            margin-bottom: 3rem;
        }
        
        h1 {
            font-size: 2.8rem;
            margin-bottom: 1rem;
        }
        
        h2 {
            font-size: 2rem;
            color: var(--primary-color);
            margin-bottom: 1.5rem;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 0.5rem;
        }
        
        h3 {
            font-size: 1.5rem;
            color: var(--secondary-color);
            margin: 1.5rem 0 1rem 0;
        }
        
        p {
            margin-bottom: 1rem;
        }
        
        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 2rem;
            margin-top: 2rem;
        }
        
        .feature-card {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            transition: transform 0.3s, box-shadow 0.3s;
        }
        
        .feature-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
        }
        
        .feature-card h3 {
            color: rgb(18, 17, 17);
            margin-top: 0;
        }
        
        .code-block {
            background-color: var(--code-bg);
            color: #f8f8f2;
            border-radius: 5px;
            padding: 1rem;
            margin: 1.5rem 0;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', monospace;
        }
        
        .btn {
            display: inline-block;
            background-color: var(--primary-color);
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 5px;
            text-decoration: none;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        
        .btn:hover {
            background-color: #3a5bd0;
        }
        
        .btn-secondary {
            background-color: var(--accent-color);
        }
        
        .btn-secondary:hover {
            background-color: #c0392b;
        }
        
        .cta-section {
            background-color: var(--primary-color);
            color: white;
            text-align: center;
            padding: 3rem 2rem;
            margin: 3rem 0;
            border-radius: 10px;
        }
        
        .cta-section h2 {
            color: white;
            border-bottom: none;
        }
        
        footer {
            background-color: var(--secondary-color);
            color: white;
            text-align: center;
            padding: 2rem;
            margin-top: 4rem;
        }
        
        .demo-container {
            margin: 2rem 0;
            padding: 2rem;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        .api-table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
        }
        
        .api-table th, .api-table td {
            padding: 0.8rem;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        
        .api-table th {
            background-color: var(--primary-color);
            color: white;
        }
        
        .api-table tr:hover {
            background-color: #f5f5f5;
        }
        
        /* Estilos nuevos para secciones desplegables */
        .collapsible {
            background-color: #e0e6f5;
            color: var(--secondary-color);
            cursor: pointer;
            padding: 1rem;
            width: 100%;
            border: none;
            text-align: left;
            outline: none;
            font-size: 1.5rem;
            font-weight: bold;
            transition: 0.4s;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-top: 1.5rem;
            border-left: 4px solid var(--primary-color);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .collapsible:hover, .collapsible.active {
            background-color: #cbd5ed;
        }
        
        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }
        
        .collapsible:after {
            content: '\002B';  /* Signo + */
            font-size: 1.5rem;
            margin-left: 5px;
        }
        
        .collapsible.active:after {
            content: "\2212";  /* Signo - */
        }
        
        /* Estilos para la galería de imágenes */
        .gallery-section {
            margin: 3rem 0;
        }
        
        .image-gallery {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-top: 1.5rem;
        }
        
        .gallery-item {
            position: relative;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
            transition: transform 0.3s, box-shadow 0.3s;
        }
        
        .gallery-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }
        
        .gallery-image {
            width: 100%;
            height: auto;
            display: block;
            transition: transform 0.5s;
        }
        
        .gallery-item:hover .gallery-image {
            transform: scale(1.05);
        }
        
        .gallery-caption {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 0.8rem;
            transform: translateY(100%);
            transition: transform 0.3s;
        }
        
        .gallery-item:hover .gallery-caption {
            transform: translateY(0);
        }
        
        /* Estilos para el lightbox */
        .lightbox {
            display: none;
            position: fixed;
            z-index: 1000;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--overlay-bg);
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .lightbox.active {
            display: flex;
            opacity: 1;
        }
        
        .lightbox-content {
            position: relative;
            max-width: 80%;
            max-height: 80vh;
            margin: auto;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }
        
        .lightbox.active .lightbox-content {
            transform: scale(1);
        }
        
        .lightbox-image {
            display: block;
            width: 100%;
            height: auto;
            max-height: 80vh;
            object-fit: contain;
        }
        
        .lightbox-close {
            position: absolute;
            top: 15px;
            right: 15px;
            font-size: 30px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        .lightbox-close:hover {
            background-color: rgba(0, 0, 0, 0.8);
        }
        
        .lightbox-caption {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            text-align: center;
        }
        
        /* Estilos para los iconos de arquitectura */
        .architecture-icon {
            width: 24px;
            height: 24px;
            margin-right: 10px;
            fill: none;
            stroke: var(--primary-color);
            stroke-width: 1.5;
            stroke-linecap: round;
            stroke-linejoin: round;
        }
        
        /* Ajustar el estilo de los botones colapsables para incluir iconos */
        .collapsible {
            display: flex;
            align-items: center;
        }
        
        .icon-title {
            margin-left: 0;
            flex-grow: 1;
        }

/* Estilos para la sección API expandible con mayor contraste */
.api-table {
    width: 100%;
    border-collapse: collapse;
    margin: 1.5rem 0;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    border-radius: 8px;
    overflow: hidden;
}

.api-table th, .api-table td {
    padding: 1rem;
    text-align: left;
    border-bottom: 1px solid #c0cfff;
}

.api-table th {
    background-color: var(--primary-color);
    color: white;
    font-size: 1.1em;
}

/* Filas expandibles */
.api-expandable-row {
    cursor: pointer;
    transition: all 0.3s;
    background-color: white;
    position: relative;
}

.api-expandable-row:hover {
    background-color: #d8e1ff;
}

/* Añadir icono de despliegue */
.api-expandable-row td:first-child::after {
    content: '+';
    position: absolute;
    right: 20px;
    color: var(--primary-color);
    font-weight: bold;
    font-size: 1.5em;
}

/* Cambiar icono cuando está expandido */
.api-expandable-row.active td:first-child::after {
    content: '−';
}

/* Filas de detalles */
.details-row {
    display: none;
    background-color: #ebf0ff;
    border-left: 5px solid var(--primary-color);
}

/* Anular cualquier hover de tabla genérico que pueda estar afectando */
.api-table tr.details-row:hover {
    background-color: #ebf0ff !important; /* Mantener el mismo color de fondo - !important para sobreescribir otros estilos */
}

.details-content {
    padding: 20px;
}

.details-content h3 {
    margin-top: 0;
    margin-bottom: 15px;
    font-size: 1.2em;
    color: var(--secondary-color);
    border-bottom: 2px solid var(--primary-color);
    padding-bottom: 8px;
    display: inline-block;
}

.details-content ul {
    margin: 0 0 20px 0;
    padding-left: 20px;
}

.details-content li {
    margin-bottom: 8px;
    line-height: 1.5;
}

.details-content code {
    background-color: #e8eaed;
    padding: 3px 6px;
    border-radius: 4px;
    font-family: 'Consolas', 'Monaco', monospace;
    color: var(--accent-color);
    font-weight: 500;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
}
        
        @media (max-width: 768px) {
            nav ul {
                flex-direction: column;
                align-items: center;
            }
            
            nav li {
                margin: 0.5rem 0;
            }
            
            .feature-grid {
                grid-template-columns: 1fr;
            }
            
            .image-gallery {
                grid-template-columns: 1fr;
            }
        }
    </style>
    
    <!-- SVG Definitions para iconos de arquitectura -->
    <svg style="display: none;">
        <!-- Icono Ventana Gráfica -->
        <symbol id="window-icon" viewBox="0 0 24 24">
            <path d="M4 4h16v16H4V4z M4 8h16 M8 4v16"/>
        </symbol>
        
        <!-- Icono Controles e Interfaz de Usuario -->
        <symbol id="ui-icon" viewBox="0 0 24 24">
            <path d="M3 3h18v18H3V3z M7 7h10v2H7V7z M7 12h10v2H7v-2z M7 17h10v2H7v-2z M20 7h1v2h-1V7z M20 12h1v2h-1v-2z M20 17h1v2h-1v-2z"/>
        </symbol>
        
        <!-- Icono Cámara Principal -->
        <symbol id="camera-icon" viewBox="0 0 24 24">
            <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2v11z"/>
            <circle cx="12" cy="13" r="4"/>
        </symbol>
        
        <!-- Icono Sistema ECS -->
        <symbol id="ecs-icon" viewBox="0 0 24 24">
            <rect x="2" y="2" width="6" height="6" rx="1"/>
            <rect x="2" y="10" width="6" height="6" rx="1"/>
            <rect x="2" y="18" width="6" height="4" rx="1"/>
            <rect x="10" y="2" width="6" height="6" rx="1"/>
            <rect x="10" y="10" width="6" height="12" rx="1"/>
            <rect x="18" y="2" width="4" height="20" rx="1"/>
        </symbol>
        
        <!-- Icono Skyboxes -->
        <symbol id="skybox-icon" viewBox="0 0 24 24">
            <path d="M12 2 L2 6 L2 18 L12 22 L22 18 L22 6 L12 2 Z"/>
            <path d="M12 2 L12 22"/>
            <path d="M2 6 L12 10 L22 6"/>
            <path d="M2 18 L12 14 L22 18"/>
        </symbol>
        
        <!-- Icono Generación de Terrenos -->
        <symbol id="terrain-icon" viewBox="0 0 24 24">
            <path d="M1 18 L5 12 L9 18 Z"/>
            <path d="M8 18 L12 8 L16 18 Z"/>
            <path d="M15 18 L19 13 L23 18 Z"/>
            <path d="M1 18 L23 18"/>
        </symbol>
        
        <!-- Icono Renderizado Diferido -->
        <symbol id="render-icon" viewBox="0 0 24 24">
            <path d="M4 4 h16 v16 h-16 z"/>
            <path d="M14 4 v4 h4"/>
            <path d="M8 10 h8 v8 h-8 z"/>
            <path d="M8 10 l8 8"/>
            <path d="M16 10 l-8 8"/>
        </symbol>
        
        <!-- Icono Bucle Principal -->
        <symbol id="loop-icon" viewBox="0 0 24 24">
            <path d="M21.5 2v6h-6M2.5 22v-6h6"/>
            <path d="M22 12c0 5-4.5 8-10 8s-8.5-3-8.5-8 3-8 8.5-8 8.5 3 10 8z"/>
        </symbol>
    </svg>
</head>
<body>
    <header>
        <div class="container">
            <h1>OPEngine</h1>
            <p>Documentación</p>
        </div>
    </header>
    
    <nav>
        <ul>
            <li><a href="#caracteristicas">Características</a></li>
            <li><a href="#arquitectura">Arquitectura</a></li>
            <li><a href="#api">API</a></li>
            <li><a href="#descargas">Instalación</a></li>
        </ul>
    </nav>
    
    <main class="container">
        <section id="introduccion">
            <h2>Introducción</h2>
            <p>Bienvenido a la documentación oficial de nuestro motor de videojuegos <strong>OPE</strong> en C++. Este motor ha sido diseñado y programado desde cero por Rubén Gil Fabregat y Pau Badía Villanueva 
            para la asignatura de Programación de Motores Gráficos. Contacto: <strong>gilfa@esat-alumni.com</strong> / <strong>badiavi@esat-alumni.com</strong></p>
        </section>
        
        <section id="caracteristicas">
            <h2>Características Principales</h2>
            <div class="feature-grid">
                <div class="feature-card">
                    <h3>Sistema de Renderizado</h3>
                    <p>Renderizado basado en OpenGL con soporte de las siguientes técnicas:</p>
                    <ul>
                        <li>Sistema de iluminación</li>
                        <li>Técnicas de sombreado</li>
                        <li>Nubes volumétricas</li>
                        <li>Ambient Occlusion</li>
                        <li>Soporte para skyboxes</li>
                    </ul>
                </div>
                
                <div class="feature-card">
                    <h3>Generación de Terreno</h3>
                    <p>Sistema avanzado de generación de terreno procedural con múltiples capas y alta personalización:</p>
                    <ul>
                        <li>Algoritmos de ruido múltiples: Perlin</li>
                        <li>Mapas de altura con resolución ajustable</li>
                        <li>Distribución de elementos ambientales</li>
                        <li>Exportación de mapas de altura y texturas</li>
                    </ul>
                </div>
                
                <div class="feature-card">
                    <h3>Sistema ECS</h3>
                    <p>Arquitectura basada en Entity Component System (ECS):</p>
                    <ul>
                        <li>Alto rendimiento y paralelización</li>
                        <li>Organización clara y mantenible</li>
                        <li>Reutilización de componentes</li>
                        <li>Escalabilidad</li>
                    </ul>
                </div>
            </div>
            
            <!-- Galería de imágenes -->
            <div class="gallery-section">
                <h3>Galería de imágenes</h3>
                <div class="image-gallery">
                    <div class="gallery-item" style="cursor: pointer;">
                        <img src="motor2.png" alt="Sistema de renderizado" class="gallery-image">
                        <div class="gallery-caption">Sistema de renderizado avanzado con iluminación Blinn-Phong</div>
                    </div>
                    <div class="gallery-item" style="cursor: pointer;">
                        <img src="motor6.png" alt="Generación de terreno procedural" class="gallery-image">
                        <div class="gallery-caption">Terreno procedural generado con algoritmos de ruido Perlin</div>
                    </div>
                    <div class="gallery-item" style="cursor: pointer;">
                        <img src="motor5.png" alt="Sistema ECS" class="gallery-image">
                        <div class="gallery-caption">Arquitectura ECS: Organización de entidades y componentes</div>
                    </div>
                    <div class="gallery-item" style="cursor: pointer;">
                        <img src="clouds.png" alt="Técnicas de sombreado" class="gallery-image">
                        <div class="gallery-caption">Efectos atmosféricos y nubes volumétricas</div>
                    </div>
                    <div class="gallery-item" style="cursor: pointer;">
                        <img src="skybox.png" alt="Skyboxes" class="gallery-image">
                        <div class="gallery-caption">Sistema de skyboxes dinámicos</div>
                    </div>
                    <div class="gallery-item" style="cursor: pointer;">
                        <img src="ssao.png" alt="Post-procesado" class="gallery-image">
                        <div class="gallery-caption">Efectos de post-procesado y ambient occlusion</div>
                    </div>
                </div>
            </div>
        </section>
        
        <section id="arquitectura">
            <h2>Arquitectura del Motor</h2>
            <button class="collapsible">
                <svg class="architecture-icon">
                    <use href="#window-icon"></use>
                </svg>
                <span class="icon-title">VENTANA GRÁFICA</span>
            </button>
            
            <div class="collapsible-content">
                <p style="text-align: justify; margin-top: 20px; margin-bottom: 20px;">Creación y gestión eficiente de ventanas gráficas. La inicialización comienza con la creación 
                de una instancia del sistema de motor <strong>[EngineSystem]</strong> y la configuración de los parámetros básicos de la ventana, utilizando la función estática <strong>[Window::make()]</strong> de la clase <strong>[Window]</strong>.</p>

                <p style="text-align: justify; margin-top: 20px; margin-bottom: 20px;">La funicón <strong>[Window::make()]</strong> devolverá un <strong>optional ptr</strong>, para obtener la variable de ventana necesitaremos mover su valor a una varibale de tipo <strong>[Window]</strong>.
                    Por último habrá que asociar la ventana creando un contexto en el sistema, para lograrlo es necesario utilizar <strong>[window.makeContext(system)]</strong>.</p>
                <div class="code-block">
                    <pre>
//ENGINE//---------------------------------------------------------------------------------------
EngineSystem system;

//CREAR VENTANA//--------------------------------------------------------------------------------
int windowWidth = 800;
int windowHeight = 600;
std::string window_name = "Main Window -- Terrain Demo";

auto opt_window = Window::make(windowWidth, windowHeight, window_name, system);
if (!opt_window) {
    std::cerr << "Error: Failed to create window." << std::endl;
    return -1;
}

//INICIALIZAR VENTANA//---------------------------------------------------------------------------
Window window = std::move(opt_window.value());
window.makeContext(system);</pre>
                </div>
            </div>

            <button class="collapsible">
                <svg class="architecture-icon">
                    <use href="#ui-icon"></use>
                </svg>
                <span class="icon-title">CONTROLES & INTERFAZ USUARIO</span>
            </button>
            <div class="collapsible-content">
                <p style="text-align: justify; margin-top: 20px; margin-bottom: 20px;">Para poder utilizar las funcionalidades de input, es necesario declarar un clase <strong>[Input]</strong> y asignarle la ventana
                que tiene en contexto el sistema del motor. De la misma forma con la clase <strong>[UIRenderer]</strong>. Estas variables inicialidas serán necesarias más adelante para otros subsistemas.</p>
                <div class="code-block">
                    <pre>
//INPUT//-----------------------------------------------------------------------------------------
Input input(window.getWindow());

//UI//--------------------------------------------------------------------------------------------
UIRenderer ui(window.getWindow());</pre>
                </div>
            </div>
            
            <button class="collapsible">
                <svg class="architecture-icon">
                    <use href="#camera-icon"></use>
                </svg>
                <span class="icon-title">CÁMARA PRINCIPAL</span>
            </button>
            <div class="collapsible-content">
                <p style="text-align: justify; margin-top: 20px; margin-bottom: 20px;">Creación y gestión de una variable Cámara. Para crear una variable <strong>[Camera]</strong>, es necesario, haber creado una clase <strong>[Input]</strong> previamente
                    y asignarla a la cámara junto a los demás parámetros de inicialización. Para utilizar dicha cámara como vista en la escena, será necesario asociarla al <strong>[RenderSystem]</strong>.</p>

                <p style="text-align: justify; margin-top: 20px; margin-bottom: 20px;">Por otro lado, el movimiento de Flycam puede ser activado, utilizando el método <strong>[camera.update()]</strong> en el Main Loop. 
                    Para poder desbloquear la rotación de la cámara es necesario pulsar la tecla <strong>[SHIFT]</strong> y para el movimiento normal <strong>[WASD]</strong>. La intensidad del <strong>[SSAO]</strong> se ajusta desde la cámara.</p>
                <div class="code-block">
                    <pre>
//CÁMARA//----------------------------------------------------------------------------------------
Camera camera(&input, glm::vec3(-90.0f, 150.0f, 130.0f),                // posición
                0.0f,                                                   // yaw
                -30.0f,                                                 // pitch
                75.0f,                                                  // fov (campo de visión)
                windowWidth / windowHeight,                             // relación de aspecto
                0.1f,                                                   // plano cercano
                15000.f);                                               // plano lejano

//ASOCIAR CÁMARA AL RENDER//----------------------------------------------------------------------
renderSystem.render(em, cm, "renderShader...", "skybox", camera);

//SSAO//------------------------------------------------------------------------------------------
camera.ambientOclussionStrenght = 1.0f;
            
//MOVIMIENTO CÁMARA FLYCAM//----------------------------------------------------------------------
float deltaTime = system.getDeltaTime();
camera.update(deltaTime);</pre>
                </div>
            </div>

            <button class="collapsible">
                <svg class="architecture-icon">
                    <use href="#ecs-icon"></use>
                </svg>
                <span class="icon-title">SISTEMA ECS</span>
            </button>
            <div class="collapsible-content">
                <p style="text-align: justify; margin-top: 20px; margin-bottom: 20px;">Creación y gestión de entidades. Para poder utilizar las herramientas ECS, es necesario crear una variable de tipo <strong>[EntityManager]</strong>
                y otra de tipo <strong>[ComponentManager]</strong>, la primera permitirá crear entidades y la segunda añadir/obtener componentes de dichas entidades.</p> 

                <p style="text-align: justify; margin-top: 20px; margin-bottom: 20px;">Para añadirle a una entidad una malla cargada desde el dispositivo, deberemos utilizar el método estático <strong>[MeshComponent::loadModel()]</strong>.
                Está función nos devuelve una variable <strong>[MeshData]</strong>, necesaria para la construcción de una variable de tipo malla, <strong>[MeshComponent(MeshData)]</strong>, una vez este componente esté inicializado se puede añadir a la entidad con
                la función <strong>[cm.addComponent(Entidad, &ltComponente&gt)]</strong>.</p> 
                
                
                <p style="text-align: justify; margin-top: 20px; margin-bottom: 20px;"></p>Si a una entidad se le añaden varios componentes del mismo tipo, se utilizará el último componente añadido.</p> 
                
                <p style="text-align: justify; margin-top: 20px; margin-bottom: 20px;">Es importante tener en cuenta que los componentes se deben obtener preferiblemente en el Main Loop.</p>
                <div class="code-block">
                    <pre>
//INICIALIZAR ECS//--------------------------------------------------------------------------------
EntityManager em;
ComponentManager cm;

//CREAR UNA ENTIDAD RENDERIZABLE//------------------------------------------------------------------
Entity Luffy = em.createEntity();
cm.addComponent(Luffy, ColorComponent{ glm::vec4(1.0, 1.0, 1.0, 1.0), true });
cm.addComponent(Luffy, TransformComponent{ glm::vec3(40.0f, 50.0f, -50.0f),
                                            glm::vec3(0.0f, 0.0f, 0.0f),
                                            glm::vec3(0.5f, 0.5f, 0.5f) });
cm.addComponent(Luffy, MeshComponent(MeshComponent::loadModel("../assets/obj/luffy.obj")));
cm.addComponent(Luffy, TextureComponent(TextureComponent::loadTexture("../assets/textures/luffyTexture.png")));

//OBTENER COMPONENTES DE ENTIDAD//-----------------------------------------------------------------
TransformComponent* tc = cm.getComponent&ltTransformComponent&gt(Luffy);
MeshComponent* mc = cm.getComponent&ltMeshComponent&gt(Luffy);
TextureComponent* texc = cm.getComponent&ltTextureComponent&gt(Luffy);</pre>
                </div>
            </div>

            <button class="collapsible">
                <svg class="architecture-icon">
                    <use href="#skybox-icon"></use>
                </svg>
                <span class="icon-title">SKYBOXES</span>
            </button>
            <div class="collapsible-content">
                <p style="text-align: justify; margin-top: 20px; margin-bottom: 20px;">Creación y gestión de skybox. Para poder añadir un skybox a la escena es necesario crear una variable de tipo <strong>[SkyboxManager]</strong>,
                este manager nos permitirá agregar varios skybox con el método <strong>[skyboxManager.add()]</strong>  para posteriormente seleccionar el que queramos renderizar.</p> 

                <p style="text-align: justify; margin-top: 20px; margin-bottom: 20px;">El formato aceptado por <strong>[skyboxManager.add()]</strong> es un CubeMap que se compone de 6 imagenes. <strong>Referencia:</strong> <a href="https://freestylized.com/all-skybox/" target="_blank">Freestylized Skybox Collection</a></p> 
                <div class="code-block">
                    <pre>
//SKYBOXES//----------------------------------------------------------------------------------------
SkyboxManager skyboxManager;

//SKYBOX - 0
skyboxManager.add({
    "../assets/skyboxes/sunset/px.png",  // POSITIVE_X
    "../assets/skyboxes/sunset/nx.png",  // NEGATIVE_X
    "../assets/skyboxes/sunset/py.png",  // POSITIVE_Y
    "../assets/skyboxes/sunset/ny.png",  // NEGATIVE_Y
    "../assets/skyboxes/sunset/pz.png",  // POSITIVE_Z
    "../assets/skyboxes/sunset/nz.png"   // NEGATIVE_Z
});

//SKYBOX - 1
skyboxManager.add({
    "../assets/skyboxes/day/px.png",  // POSITIVE_X
    "../assets/skyboxes/day/nx.png",  // NEGATIVE_X
    "../assets/skyboxes/day/py.png",  // POSITIVE_Y
    "../assets/skyboxes/day/ny.png",  // NEGATIVE_Y
    "../assets/skyboxes/day/pz.png",  // POSITIVE_Z
    "../assets/skyboxes/day/nz.png"   // NEGATIVE_Z
});

//RENDERIZAR SKYBOX -> 1
renderSystem.skyboxSelector = 1;

//ASOCIAR SKYBOX MANAGER AL RENDER//---------------------------------------------------------------
renderSystem.render(em, cm, "renderShader...", skyboxManager, camera);</pre>
                </div>
            </div>

            <button class="collapsible">
                <svg class="architecture-icon">
                    <use href="#terrain-icon"></use>
                </svg>
                <span class="icon-title">GENERACIÓN DE TERRENOS</span>
            </button>
            <div class="collapsible-content">
                <p style="text-align: justify; margin-top: 20px; margin-bottom: 20px;">La generación de Terrenos se divide en 3 secciones. La primera sección consiste en generar el mapa de alturas con la clase <strong>[HeightmapGenerator]</strong> y el método
                 <strong>[heightmap.generateHeightmap()]</strong>, esto generará una imagen de heightmap guardada en nuestro dispositivo, también podemos hacerlo respectivamente con el colormap del terreno 
                 utilizando <strong>[heightmap.generateColorMap()]</strong>, esto generará una textura que al asignarla al terreno dará un color por alturas.</p> 

                 <p style="text-align: justify; margin-top: 20px; margin-bottom: 20px;">La segunda sección consiste en transformar la imagen heightmap generada previamente en una malla de terreno, para lograr esta función es necesario
                    leer el archivo imagen heightmap del dispositivo y almacenarlo en una variable de tipo <strong>[TextureImage]</strong>, una vez hecho esto, al añadir un componente <strong>[Mesh]</strong> en lugar de cargar un modelo, hay que utilizar el
                    método estático <strong>[MeshComponent::loadHeightMap()]</strong>.
                 </p> 

                 <p style="text-align: justify; margin-top: 20px; margin-bottom: 20px;">La tercera y última sección consiste en generar assets distribuidos por altura y cantidad en un terreno (compatible con otros modelos 3D). Para lograr este resultado
                    se debe crear una variable <strong>[Generation]</strong> para cada iteración de generación, también se debe asociar en su inicialización una entidad que contenga un componente <strong>[Mesh]</strong>, si la entidad no contiene dicho componente la generación fallará.
                 </p> 

                <div class="code-block">
                    <pre>
//GENERADOR MAPA DE ALTURA//-----------------------------------------------------------------------
HeightmapGenerator heightmap(512, 512);
heightmap.generateHeightmap(0.01, 4, 0.4, 2.2);
heightmap.applyIslandMask(1.5);
heightmap.saveAsImage("../assets/heightmaps/heightmap.png");
std::vector<uint8_t> colorMap = heightmap.generateColorMap();
heightmap.saveColorMapAsImage("../assets/heightmaps/heightmap_colormap.png", colorMap, heightmap.width, heightmap.height);

//ENTIDAD DE TERRENO//------------------------------------------------------------------------------
TextureImage h_map_tex = TextureComponent::loadTexture("../assets/heightmaps/heightmap.png");
Entity h_map = em.createEntity();
cm.addComponent(h_map, ColorComponent{ glm::vec4(1.0f, 1.0f, 1.0f, 1.0f), true});
cm.addComponent(h_map, TransformComponent{
       glm::vec3(0.0f, 0.0f, 0.0f),
       glm::vec3(0.0f, 0.0f, 0.0f),
       glm::vec3(0.5f, 0.5f, 0.5f) });
cm.addComponent(h_map, MeshComponent(MeshComponent::loadHeightMap(h_map_tex, 620.0f, 1.0f)));
cm.addComponent(h_map, TextureComponent(TextureComponent::loadTexture("../assets/heightmaps/heightmap_colormap.png")));

//GENERACIÓN DE ASSETS EN UN TERRENO//----------------------------------------------------------------
MeshData palm = MeshComponent::loadModel("../assets/obj/palm.obj");
std::shared_ptr<TextureImage> palmTexture = std::make_shared<TextureImage>(TextureComponent::loadTexture("../assets/textures/palmTexture.png"));
Generation gen(em, cm, h_map, palm, glm::vec3(3.0f, 4.0f, 3.0f), palmTexture, glm::vec2(4.0f, 11.0f),

MeshData grass = MeshComponent::loadModel("../assets/obj/grass.obj");
std::shared_ptr<TextureImage> grassTexture = std::make_shared<TextureImage>(TextureComponent::loadTexture("../assets/textures/grassTexture.png"));
Generation gen2(em, cm, h_map, grass, glm::vec3(3.0f, 7.5f, 3.0f), grassTexture, glm::vec2(16.0f, 25.0f), 70);</pre>
                </div>
            </div>

            <button class="collapsible">
                <svg class="architecture-icon">
                    <use href="#render-icon"></use>
                </svg>
                <span class="icon-title">RENDERIZADO DIFERIDO</span>
            </button>
            <div class="collapsible-content">
                <p style="text-align: justify; margin-top: 20px; margin-bottom: 20px;">Sistema de renderizado principal. Todas las entidades que tengan los siguientes componentes serán renderizadas en la escena:
                    <strong>[ColorComponent], [TransformComponent], [MeshComponent] y [TextureComponent]</strong>. Si falta algún componente mencionado anteriormente la entidad respectiva no se renderizará. 
                    Si se desea que una entidad no genere sombra, <strong>ColorComponent{ glm::vec4(1.0f, 1.0f, 1.0f, 1.0f), <strong>castShadow = false</strong>};</strong>
                </p>

                <p style="text-align: justify; margin-top: 20px; margin-bottom: 20px;">El motor da soporte a los <strong>[OPE Default Shaders]</strong>, estos shaders son esenciales al momento de realizar el renderizado,
                    es posible utilizar shaders customizados pero se recomienda el uso de los nativos del motor. Estos se incluyen en la siguiente ruta: <strong>"../shaders/vertex/vsShader"</strong> y <strong>"../shaders/fragment/fsShader"</strong>.</p>
                    
                <p style="text-align: justify; margin-top: 20px; margin-bottom: 20px;">Si se desea utilizar un shader específico para calcular el albedo de una entidad, existe <strong>[CustomShaderComponent]</strong>,
                    si dicha entidad lleva este componente, el <strong>[GeometryShader]</strong> del motor será sobreescrito a la hora de renderizar dicha entidad por el shader personalizado correspondiente. El shader debe de tener
                    una estructura similiar al shader de geometría para escribir en los gBuffers adecuadamente, de lo contrario, no se trasmitirá en el resultado.</p>
                    
                    <p style="text-align: justify; margin-top: 20px; margin-bottom: 20px;"></p><strong>!!!</strong><strong>[CustomShaderComponent]</strong> se encuentra en fase de desarrollo, consultar con los desarrolladores<strong>!!!</strong></p>

                <div class="code-block">
                    <pre>
//INICIALIZAR//------------------------------------------------------------------------------------                
RenderSystem renderSystem(false, windowWidth, windowHeight);

//OPE DEFAULT SHADERS RENDER SYSTEM//--------------------------------------------------------------
std::shared_ptr<Shader> geometryShader = std::make_shared<Shader>("../shaders/vertex/geometrypassDeferredRendering.vs", "../shaders/fragment/geometrypassDeferredRendering.fs");
std::shared_ptr<Shader> lightShader = std::make_shared<Shader>("../shaders/vertex/lightpassDeferredRendering.vs", "../shaders/fragment/lightpassDeferredRendering.fs");
std::shared_ptr<Shader> shadowShader = std::make_shared<Shader>("../shaders/vertex/pointShadowPass.vs", "../shaders/fragment/pointShadowPass.fs", "../shaders/geometry/pointShadowPass.gs");
std::shared_ptr<Shader> ssaoShader = std::make_shared<Shader>("../shaders/vertex/ssaoPass.vs", "../shaders/fragment/ssaoPass.fs");
std::shared_ptr<Shader> ssaoBlurShader = std::make_shared<Shader>("../shaders/vertex/ssaoBlurPass.vs", "../shaders/fragment/ssaoBlurPass.fs");
std::shared_ptr<Shader> skyboxShader = std::make_shared<Shader>("../shaders/vertex/skybox.vs", "../shaders/fragment/skybox.fs");
std::shared_ptr<Shader> cloudShader = std::make_shared<Shader>("../shaders/vertex/cloudShader.vs", "../shaders/fragment/cloudShader.fs");

//MAIN LOOP//--------------------------------------------------------------------------------------  
renderSystem.render(em, cm, geometryShader, lightShader, shadowShader, ssaoShader, ssaoBlurShader, skyboxShader, cloudShader, skyboxManager, camera);

//CUSTOM GEOMETRY SHADER//------------------------------------------------------------------------------------  
std::shared_ptr<Shader> oceanShader = std::make_shared<Shader>("../shaders/vertex/oceanShader.vs", "../shaders/fragment/oceanShader.fs");

cm.addComponent(ocean, CustomShaderComponent(oceanShader, TextureComponent(TextureComponent::loadTexture("../assets/heightmaps/image.png")), 
                                                          TextureComponent(TextureComponent::loadTexture("../assets/normalMaps/water_normal.jpg"))));</pre>
                </div>
            </div>

            <button class="collapsible">
                <svg class="architecture-icon">
                    <use href="#loop-icon"></use>
                </svg>
                <span class="icon-title">BUCLE PRINCIPAL</span>
            </button>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre>
//MAIN LOOP//---------------------------------------------------------------------------------------
while (window.isOpen()) {

    window.clear(0.0f, 0.0f, 0.0f, 1.0f);
    float deltaTime = system.getDeltaTime();

    //INPUT-----------------------------------------------------------------------------------------
    input.updateKeyStates();

    //CAMERA----------------------------------------------------------------------------------------
    camera.update(deltaTime);

    //UPDATE----------------------------------------------------------------------------------------
    TransformComponent* tc = cm.getComponent<TransformComponent>(light);
    LightComponent* lc = cm.getComponent<LightComponent>(light);
    ColorComponent* cc = cm.getComponent<ColorComponent>(h_map);

    //RENDER----------------------------------------------------------------------------------------    
    renderSystem.render(em, cm, geometryShader, lightShader, shadowShader, ssaoShader, ssaoBlurShader, 
                        skyboxShader, cloudShader, skyboxManager, camera);

    //HUD-------------------------------------------------------------------------------------------
    ui.newFrame();

    //Renderizar primero si el output final es en una textura
    ui.renderWindow(renderSystem);

    ui.entityViewer(em);
    ui.renderTextureWindow(cm.getComponent<TextureComponent>(h_map)->ID);
    ui.settingsWindow(camera, lc, renderSystem, renderSystem.textureType, renderSystem.bSkybox, 
                        renderSystem.skyboxSelector, renderSystem.bClouds);

    //CUSTOM WINDOW           
    ImGui::Begin("FPS");
    ImGui::Text("FPS: %.2f", system.displayFPS());
    ImGui::End();

    ui.endFrame();

    window.swapBuffers();
    window.pollEvents();
}</pre>
                </div>
            </div>

        </section>
            
        <section id="api">
            <h2>Referencia de API</h2>
        
            <table class="api-table">
                <tr>
                    <th>Clase/Función</th>
                    <th>Descripción</th>
                </tr>
                <tr class="expandable-row" onclick="toggleDetails('renderer')">
                    <td>Renderer</td>
                    <td>Clase principal para gestionar el renderizado de la escena</td>
                </tr>
                <tr id="renderer" class="details-row">
                    <td colspan="2">
                        <div class="details-content">
                            <h3>Variables:</h3>
                            <ul>
                                <li><code>canvas</code> - Elemento HTML Canvas para renderizar</li>
                                <li><code>context</code> - Contexto WebGL</li>
                                <li><code>width</code> - Ancho del viewport</li>
                                <li><code>height</code> - Alto del viewport</li>
                            </ul>
                            <h3>Métodos:</h3>
                            <ul>
                                <li><code>initialize(canvas)</code> - Inicializa el renderizador con un canvas</li>
                                <li><code>setSize(width, height)</code> - Establece el tamaño del viewport</li>
                                <li><code>render(scene, camera)</code> - Renderiza una escena con una cámara</li>
                                <li><code>clear()</code> - Limpia el buffer de renderizado</li>
                            </ul>
                        </div>
                    </td>
                </tr>
                
                <tr class="expandable-row" onclick="toggleDetails('material')">
                    <td>Material</td>
                    <td>Define propiedades de superficie para objetos 3D</td>
                </tr>
                <tr id="material" class="details-row">
                    <td colspan="2">
                        <div class="details-content">
                            <h3>Variables:</h3>
                            <ul>
                                <li><code>type</code> - Tipo de material (básico, phong, etc.)</li>
                                <li><code>color</code> - Color base del material</li>
                                <li><code>opacity</code> - Nivel de opacidad (0-1)</li>
                                <li><code>transparent</code> - Si el material es transparente</li>
                            </ul>
                            <h3>Métodos:</h3>
                            <ul>
                                <li><code>setColor(r, g, b)</code> - Establece el color RGB</li>
                                <li><code>setOpacity(value)</code> - Establece la opacidad</li>
                                <li><code>setTexture(texture)</code> - Asigna una textura</li>
                                <li><code>clone()</code> - Crea una copia del material</li>
                            </ul>
                        </div>
                    </td>
                </tr>
                
                <tr class="expandable-row" onclick="toggleDetails('shader')">
                    <td>Shader</td>
                    <td>Encapsula programas de sombreado GLSL</td>
                </tr>
                <tr id="shader" class="details-row">
                    <td colspan="2">
                        <div class="details-content">
                            <h3>Variables:</h3>
                            <ul>
                                <li><code>vertexSource</code> - Código fuente del shader de vértices</li>
                                <li><code>fragmentSource</code> - Código fuente del shader de fragmentos</li>
                                <li><code>program</code> - Programa WebGL compilado</li>
                            </ul>
                            <h3>Métodos:</h3>
                            <ul>
                                <li><code>compile()</code> - Compila los shaders y crea el programa</li>
                                <li><code>use()</code> - Activa este programa shader</li>
                                <li><code>setUniform(name, value)</code> - Establece un valor uniforme</li>
                                <li><code>getAttributeLocation(name)</code> - Obtiene la ubicación de un atributo</li>
                            </ul>
                        </div>
                    </td>
                </tr>
                
                <tr class="expandable-row" onclick="toggleDetails('mesh')">
                    <td>Mesh</td>
                    <td>Representa geometría 3D con vértices e índices</td>
                </tr>
                <tr id="mesh" class="details-row">
                    <td colspan="2">
                        <div class="details-content">
                            <h3>Variables:</h3>
                            <ul>
                                <li><code>vertices</code> - Array de vértices</li>
                                <li><code>normals</code> - Array de normales</li>
                                <li><code>uvs</code> - Array de coordenadas de textura</li>
                                <li><code>indices</code> - Array de índices</li>
                                <li><code>material</code> - Material asignado</li>
                            </ul>
                            <h3>Métodos:</h3>
                            <ul>
                                <li><code>setGeometry(vertices, indices)</code> - Establece datos geométricos</li>
                                <li><code>computeNormals()</code> - Calcula normales de vértices</li>
                                <li><code>setMaterial(material)</code> - Asigna un material</li>
                                <li><code>transform(matrix)</code> - Aplica una transformación</li>
                            </ul>
                        </div>
                    </td>
                </tr>
                
                <tr class="expandable-row" onclick="toggleDetails('texture')">
                    <td>Texture</td>
                    <td>Gestiona recursos de texturas 2D/3D/Cubemap</td>
                </tr>
                <tr id="texture" class="details-row">
                    <td colspan="2">
                        <div class="details-content">
                            <h3>Variables:</h3>
                            <ul>
                                <li><code>width</code> - Ancho de la textura</li>
                                <li><code>height</code> - Alto de la textura</li>
                                <li><code>format</code> - Formato (RGB, RGBA, etc.)</li>
                                <li><code>type</code> - Tipo (2D, 3D, Cubemap)</li>
                            </ul>
                            <h3>Métodos:</h3>
                            <ul>
                                <li><code>load(url)</code> - Carga una textura desde una URL</li>
                                <li><code>bind(unit)</code> - Vincula la textura a una unidad</li>
                                <li><code>setFiltering(min, mag)</code> - Establece filtros</li>
                                <li><code>generateMipmaps()</code> - Genera mipmaps</li>
                            </ul>
                        </div>
                    </td>
                </tr>
            </table>
        </section>
        
        <section id="descargas">
            <h2>Instalación</h2>
            
            <div class="feature-grid">
                <div class="feature-card">
                    <h3>Pasos para la instalación</h3>
                    <ol>
                        <li>Ejecuta tools\gendeps.bat para generar las dependencias.</li>
                        <li>Ejecuta tools\genproject.bat para crear la solución de Visual Studio.</li>
                    </ol>
                </div>
            </div>
        </section>
    </main>
    
    <footer>
        <div class="container">
            <p>&copy; 2025 OPEngine. Todos los derechos reservados para Rubén Gil Fabregat y Pau Badía Villanueva.</p>
        </div>
    </footer>
    
    <!-- Lightbox para las imágenes -->
    <div class="lightbox" id="imageLightbox">
        <div class="lightbox-content">
            <img src="" alt="" class="lightbox-image" id="lightboxImage">
            <div class="lightbox-caption" id="lightboxCaption"></div>
            <div class="lightbox-close">&times;</div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Script para los elementos desplegables
            var coll = document.getElementsByClassName("collapsible");
            for (var i = 0; i < coll.length; i++) {
                coll[i].addEventListener("click", function() {
                    this.classList.toggle("active");
                    var content = this.nextElementSibling;
                    if (content.style.maxHeight) {
                        content.style.maxHeight = null;
                    } else {
                        content.style.maxHeight = content.scrollHeight + "px";
                    }
                });
            }
            
            // Script para el lightbox de imágenes
            const galleryItems = document.querySelectorAll('.gallery-item');
            const lightbox = document.getElementById('imageLightbox');
            const lightboxImg = document.getElementById('lightboxImage');
            const lightboxCaption = document.getElementById('lightboxCaption');
            const closeBtn = document.querySelector('.lightbox-close');
            
            // Función para abrir el lightbox
            function openLightbox(src, alt, caption) {
                lightboxImg.src = src;
                lightboxImg.alt = alt;
                lightboxCaption.textContent = caption;
                lightbox.classList.add('active');
                document.body.style.overflow = 'hidden'; // Prevenir scroll
            }
            
            // Función para cerrar el lightbox
            function closeLightbox() {
                lightbox.classList.remove('active');
                setTimeout(() => {
                    lightboxImg.src = '';
                }, 300);
                document.body.style.overflow = ''; // Restaurar scroll
            }
            
            // Añadir eventos a las imágenes de la galería
            galleryItems.forEach(item => {
                item.addEventListener('click', function() {
                    const img = this.querySelector('img');
                    const caption = this.querySelector('.gallery-caption').textContent;
                    openLightbox(img.src, img.alt, caption);
                });
            });
            
            // Cerrar el lightbox al hacer clic en el botón de cerrar
            closeBtn.addEventListener('click', closeLightbox);
            
            // Cerrar el lightbox al hacer clic fuera de la imagen
            lightbox.addEventListener('click', function(e) {
                if (e.target === lightbox) {
                    closeLightbox();
                }
            });
            
            // Cerrar el lightbox con la tecla ESC
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && lightbox.classList.contains('active')) {
                    closeLightbox();
                }
            });
        });


/* Script JavaScript */
function toggleDetails(id) {
    const element = document.getElementById(id);
    // Encontrar la fila expandible que activó esta acción
    const expandableRow = document.querySelector(`[onclick="toggleDetails('${id}')"]`);
    
    if (element.style.display === "table-row") {
        // Ocultar detalles
        element.style.display = "none";
        // Quitar clase active de la fila expandible
        expandableRow.classList.remove("active");
    } else {
        // Mostrar detalles
        element.style.display = "table-row";
        // Añadir clase active a la fila expandible
        expandableRow.classList.add("active");
    }
}

// Inicializar todas las filas de detalles como ocultas
document.addEventListener('DOMContentLoaded', function() {
    const apiDetailsRows = document.querySelectorAll('.details-row');
    apiDetailsRows.forEach(function(row) {
        row.style.display = 'none';
    });
});
    </script>
</body>
</html>