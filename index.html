<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="logo.png">
    <title>OPEngine</title>
    <style>

    .download-section {
        margin-top: 2rem;
        padding: 1.5rem;
        background: linear-gradient(135deg, #f0f4ff, #e6ecff);
        border-radius: 10px;
        border-left: 4px solid var(--primary-color);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
    }
    
    .download-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 1rem 2rem;
        margin: 1rem 0;
        font-size: 1.1rem;
        background: linear-gradient(135deg, var(--primary-color), #2c4abb);
        color: white;
        border-radius: 8px;
        transition: all 0.3s ease;
        box-shadow: 0 4px 10px rgba(74, 109, 229, 0.3);
        text-decoration: none;
    }
    
    .download-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 15px rgba(74, 109, 229, 0.4);
        background: linear-gradient(135deg, #5a7af0, #3a5bd0);
    }
    
    .download-icon {
        display: inline-block;
        width: 20px;
        height: 20px;
        margin-right: 10px;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4'/%3E%3Cpolyline points='7 10 12 15 17 10'/%3E%3Cline x1='12' y1='15' x2='12' y2='3'/%3E%3C/svg%3E");
        background-size: contain;
        background-repeat: no-repeat;
    }
    
    .download-info {
        font-size: 0.9rem;
        color: #666;
        margin-top: 0.5rem;
    }

        :root {
            --primary-color: #4a6de5;
            --secondary-color: #2c3e50;
            --accent-color: #e74c3c;
            --text-color: #333;
            --light-bg: #f9f9f9;
            --code-bg: #282c34;
            --overlay-bg: rgba(0, 0, 0, 0.8);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--light-bg);
        }
        
        header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 2rem 0;
            text-align: center;
        }
        
        nav {
            background-color: var(--secondary-color);
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        nav ul {
            display: flex;
            justify-content: center;
            list-style-type: none;
            padding: 0.8rem 0;
        }
        
        nav li {
            margin: 0 1.5rem;
        }
        
        nav a {
            color: white;
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s;
        }
        
        nav a:hover {
            color: var(--accent-color);
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        section {
            margin-bottom: 3rem;
        }
        
        h1 {
            font-size: 2.8rem;
            margin-bottom: 1rem;
        }
        
        h2 {
            font-size: 2rem;
            color: var(--primary-color);
            margin-bottom: 1.5rem;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 0.5rem;
        }
        
        h3 {
            font-size: 1.5rem;
            color: var(--secondary-color);
            margin: 1.5rem 0 1rem 0;
        }
        
        p {
            margin-bottom: 1rem;
        }
        
        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 2rem;
            margin-top: 2rem;
        }
        
        .feature-card {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            transition: transform 0.3s, box-shadow 0.3s;
        }
        
        .feature-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
        }
        
        .feature-card h3 {
            color: rgb(18, 17, 17);
            margin-top: 0;
        }
        
        .code-block {
            background-color: var(--code-bg);
            color: #f8f8f2;
            border-radius: 5px;
            padding: 1rem;
            margin: 1.5rem 0;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', monospace;
        }
        
        .btn {
            display: inline-block;
            background-color: var(--primary-color);
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 5px;
            text-decoration: none;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        
        .btn:hover {
            background-color: #3a5bd0;
        }
        
        .btn-secondary {
            background-color: var(--accent-color);
        }
        
        .btn-secondary:hover {
            background-color: #c0392b;
        }
        
        .cta-section {
            background-color: var(--primary-color);
            color: white;
            text-align: center;
            padding: 3rem 2rem;
            margin: 3rem 0;
            border-radius: 10px;
        }
        
        .cta-section h2 {
            color: white;
            border-bottom: none;
        }
        
        footer {
            background-color: var(--secondary-color);
            color: white;
            text-align: center;
            padding: 2rem;
            margin-top: 4rem;
        }
        
        .demo-container {
            margin: 2rem 0;
            padding: 2rem;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        .api-table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
        }
        
        .api-table th, .api-table td {
            padding: 0.8rem;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        
        .api-table th {
            background-color: var(--primary-color);
            color: white;
        }
        
        .api-table tr:hover {
            background-color: #f5f5f5;
        }
        
        /* Estilos nuevos para secciones desplegables */
        .collapsible {
            background-color: #e0e6f5;
            color: var(--secondary-color);
            cursor: pointer;
            padding: 1rem;
            width: 100%;
            border: none;
            text-align: left;
            outline: none;
            font-size: 1.5rem;
            font-weight: bold;
            transition: 0.4s;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-top: 1.5rem;
            border-left: 4px solid var(--primary-color);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .collapsible:hover, .collapsible.active {
            background-color: #cbd5ed;
        }
        
        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }
        
        .collapsible:after {
            content: '\002B';  /* Signo + */
            font-size: 1.5rem;
            margin-left: 5px;
        }
        
        .collapsible.active:after {
            content: "\2212";  /* Signo - */
        }
        
        /* Estilos para la galería de imágenes */
        .gallery-section {
            margin: 3rem 0;
        }
        
        .image-gallery {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-top: 1.5rem;
        }
        
        .gallery-item {
            position: relative;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
            transition: transform 0.3s, box-shadow 0.3s;
        }
        
        .gallery-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }
        
        .gallery-image {
            width: 100%;
            height: auto;
            display: block;
            transition: transform 0.5s;
        }
        
        .gallery-item:hover .gallery-image {
            transform: scale(1.05);
        }
        
        .gallery-caption {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 0.8rem;
            transform: translateY(100%);
            transition: transform 0.3s;
        }
        
        .gallery-item:hover .gallery-caption {
            transform: translateY(0);
        }
        
        /* Estilos para el lightbox */
        .lightbox {
            display: none;
            position: fixed;
            z-index: 1000;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--overlay-bg);
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .lightbox.active {
            display: flex;
            opacity: 1;
        }
        
        .lightbox-content {
            position: relative;
            max-width: 80%;
            max-height: 80vh;
            margin: auto;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }
        
        .lightbox.active .lightbox-content {
            transform: scale(1);
        }
        
        .lightbox-image {
            display: block;
            width: 100%;
            height: auto;
            max-height: 80vh;
            object-fit: contain;
        }
        
        .lightbox-close {
            position: absolute;
            top: 15px;
            right: 15px;
            font-size: 30px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        .lightbox-close:hover {
            background-color: rgba(0, 0, 0, 0.8);
        }
        
        .lightbox-caption {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            text-align: center;
        }
        
        /* Estilos para los iconos de arquitectura */
        .architecture-icon {
            width: 24px;
            height: 24px;
            margin-right: 10px;
            fill: none;
            stroke: var(--primary-color);
            stroke-width: 1.5;
            stroke-linecap: round;
            stroke-linejoin: round;
        }
        
        /* Ajustar el estilo de los botones colapsables para incluir iconos */
        .collapsible {
            display: flex;
            align-items: center;
        }
        
        .icon-title {
            margin-left: 0;
            flex-grow: 1;
        }

/* Estilos para la sección API expandible con mayor contraste */
.api-table {
    width: 100%;
    border-collapse: collapse;
    margin: 1.5rem 0;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    border-radius: 8px;
    overflow: hidden;
}

.api-table th, .api-table td {
    padding: 1rem;
    text-align: left;
    border-bottom: 1px solid #c0cfff;
}

.api-table th {
    background-color: var(--primary-color);
    color: white;
    font-size: 1.1em;
}

/* Filas expandibles */
.api-expandable-row {
    cursor: pointer;
    transition: all 0.3s;
    background-color: white;
    position: relative;
}

.api-expandable-row:hover {
    background-color: #d8e1ff;
}

/* Añadir icono de despliegue */
.api-expandable-row td:first-child::after {
    content: '+';
    position: absolute;
    right: 20px;
    color: var(--primary-color);
    font-weight: bold;
    font-size: 1.5em;
}

/* Cambiar icono cuando está expandido */
.api-expandable-row.active td:first-child::after {
    content: '−';
}

/* Filas de detalles */
.details-row {
    display: none;
    background-color: #ebf0ff;
    border-left: 5px solid var(--primary-color);
}

/* Anular cualquier hover de tabla genérico que pueda estar afectando */
.api-table tr.details-row:hover {
    background-color: #ebf0ff !important; /* Mantener el mismo color de fondo - !important para sobreescribir otros estilos */
}

.details-content {
    padding: 20px;
}

.details-content h3 {
    margin-top: 0;
    margin-bottom: 15px;
    font-size: 1.2em;
    color: var(--secondary-color);
    border-bottom: 2px solid var(--primary-color);
    padding-bottom: 8px;
    display: inline-block;
}

.details-content ul {
    margin: 0 0 20px 0;
    padding-left: 20px;
}

.details-content li {
    margin-bottom: 8px;
    line-height: 1.5;
}

.details-content code {
    background-color: #e8eaed;
    padding: 3px 6px;
    border-radius: 4px;
    font-family: 'Consolas', 'Monaco', monospace;
    color: var(--accent-color);
    font-weight: 500;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
}

.search-container {
    margin: 1.5rem 0;
    position: relative;
    width: 100%;
    max-width: 600px;
}

.api-search-input {
    width: 100%;
    padding: 12px 40px 12px 15px;
    font-size: 16px;
    border-radius: 8px;
    border: 2px solid var(--primary-color);
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    transition: all 0.3s;
}

.api-search-input:focus {
    outline: none;
    box-shadow: 0 2px 15px rgba(74, 109, 229, 0.3);
    border-color: var(--primary-color);
}

.api-search-clear {
    position: absolute;
    right: 10px;
    top: 50%;
    transform: translateY(-50%);
    background: none;
    border: none;
    font-size: 22px;
    color: #999;
    cursor: pointer;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: all 0.2s;
}

.api-search-clear:hover {
    background-color: #f0f0f0;
    color: var(--accent-color);
}

.api-search-clear.hidden {
    display: none;
}

.api-search-highlight {
    background-color: rgba(231, 76, 60, 0.2);
    padding: 2px;
    border-radius: 3px;
}

tr.hidden-row {
    display: none;
}

.no-results-message {
    padding: 20px;
    text-align: center;
    font-size: 16px;
    color: #666;
    background-color: #f9f9f9;
    border-radius: 8px;
    margin: 20px 0;
    display: none;
}
        
        @media (max-width: 768px) {
            nav ul {
                flex-direction: column;
                align-items: center;
            }
            
            nav li {
                margin: 0.5rem 0;
            }
            
            .feature-grid {
                grid-template-columns: 1fr;
            }
            
            .image-gallery {
                grid-template-columns: 1fr;
            }
        }
    </style>
    
    <!-- SVG Definitions para iconos de arquitectura -->
    <svg style="display: none;">
        <!-- Icono Ventana Gráfica -->
        <symbol id="window-icon" viewBox="0 0 24 24">
            <path d="M4 4h16v16H4V4z M4 8h16 M8 4v16"/>
        </symbol>
        
        <!-- Icono Controles e Interfaz de Usuario -->
        <symbol id="ui-icon" viewBox="0 0 24 24">
            <path d="M3 3h18v18H3V3z M7 7h10v2H7V7z M7 12h10v2H7v-2z M7 17h10v2H7v-2z M20 7h1v2h-1V7z M20 12h1v2h-1v-2z M20 17h1v2h-1v-2z"/>
        </symbol>
        
        <!-- Icono Cámara Principal -->
        <symbol id="camera-icon" viewBox="0 0 24 24">
            <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2v11z"/>
            <circle cx="12" cy="13" r="4"/>
        </symbol>
        
        <!-- Icono Sistema ECS -->
        <symbol id="ecs-icon" viewBox="0 0 24 24">
            <rect x="2" y="2" width="6" height="6" rx="1"/>
            <rect x="2" y="10" width="6" height="6" rx="1"/>
            <rect x="2" y="18" width="6" height="4" rx="1"/>
            <rect x="10" y="2" width="6" height="6" rx="1"/>
            <rect x="10" y="10" width="6" height="12" rx="1"/>
            <rect x="18" y="2" width="4" height="20" rx="1"/>
        </symbol>
        
        <!-- Icono Skyboxes -->
        <symbol id="skybox-icon" viewBox="0 0 24 24">
            <path d="M12 2 L2 6 L2 18 L12 22 L22 18 L22 6 L12 2 Z"/>
            <path d="M12 2 L12 22"/>
            <path d="M2 6 L12 10 L22 6"/>
            <path d="M2 18 L12 14 L22 18"/>
        </symbol>
        
        <!-- Icono Generación de Terrenos -->
        <symbol id="terrain-icon" viewBox="0 0 24 24">
            <path d="M1 18 L5 12 L9 18 Z"/>
            <path d="M8 18 L12 8 L16 18 Z"/>
            <path d="M15 18 L19 13 L23 18 Z"/>
            <path d="M1 18 L23 18"/>
        </symbol>
        
        <!-- Icono Renderizado Diferido -->
        <symbol id="render-icon" viewBox="0 0 24 24">
            <path d="M4 4 h16 v16 h-16 z"/>
            <path d="M14 4 v4 h4"/>
            <path d="M8 10 h8 v8 h-8 z"/>
            <path d="M8 10 l8 8"/>
            <path d="M16 10 l-8 8"/>
        </symbol>
        
        <!-- Icono Bucle Principal -->
        <symbol id="loop-icon" viewBox="0 0 24 24">
            <path d="M21.5 2v6h-6M2.5 22v-6h6"/>
            <path d="M22 12c0 5-4.5 8-10 8s-8.5-3-8.5-8 3-8 8.5-8 8.5 3 10 8z"/>
        </symbol>
    </svg>
</head>
<body>
    <header>
        <div class="container">
            <h1>OPEngine</h1>
            <p>Documentación</p>
        </div>
    </header>
    
    <nav>
        <ul>
            <li><a href="#caracteristicas">Características</a></li>
            <li><a href="#arquitectura">Arquitectura</a></li>
            <li><a href="#api">API</a></li>
            <li><a href="#descargas">Instalación</a></li>
        </ul>
    </nav>
    
    <main class="container">
        <section id="introduccion">
            <h2>Introducción</h2>
            <p>Bienvenido a la documentación oficial de nuestro motor de videojuegos <strong>OPE</strong> en C++. Este motor ha sido diseñado y programado desde cero por Rubén Gil Fabregat y Pau Badía Villanueva 
            para la asignatura de Programación de Motores Gráficos. Contacto: <strong>gilfa@esat-alumni.com</strong> / <strong>badiavi@esat-alumni.com</strong></p>
        </section>
        
        <section id="caracteristicas">
            <h2>Características Principales</h2>
            <div class="feature-grid">
                <div class="feature-card">
                    <h3>Sistema de Renderizado</h3>
                    <p>Renderizado basado en OpenGL con soporte de las siguientes técnicas:</p>
                    <ul>
                        <li>Sistema de iluminación</li>
                        <li>Técnicas de sombreado</li>
                        <li>Nubes volumétricas</li>
                        <li>Ambient Occlusion</li>
                        <li>Soporte para skyboxes</li>
                    </ul>
                </div>
                
                <div class="feature-card">
                    <h3>Generación de Terreno</h3>
                    <p>Sistema avanzado de generación de terreno procedural con múltiples capas y alta personalización:</p>
                    <ul>
                        <li>Algoritmos de ruido múltiples: Perlin</li>
                        <li>Mapas de altura con resolución ajustable</li>
                        <li>Distribución de elementos ambientales</li>
                        <li>Exportación de mapas de altura y texturas</li>
                    </ul>
                </div>
                
                <div class="feature-card">
                    <h3>Sistema ECS</h3>
                    <p>Arquitectura basada en Entity Component System (ECS):</p>
                    <ul>
                        <li>Alto rendimiento y paralelización</li>
                        <li>Organización clara y mantenible</li>
                        <li>Reutilización de componentes</li>
                        <li>Escalabilidad</li>
                    </ul>
                </div>
            </div>
            
            <!-- Galería de imágenes -->
            <div class="gallery-section">
                <h3>Galería de imágenes</h3>
                <div class="image-gallery">
                    <div class="gallery-item" style="cursor: pointer;">
                        <img src="motor2.png" alt="Sistema de renderizado" class="gallery-image">
                        <div class="gallery-caption">Sistema de renderizado avanzado con iluminación Blinn-Phong</div>
                    </div>
                    <div class="gallery-item" style="cursor: pointer;">
                        <img src="motor6.png" alt="Generación de terreno procedural" class="gallery-image">
                        <div class="gallery-caption">Terreno procedural generado con algoritmos de ruido Perlin</div>
                    </div>
                    <div class="gallery-item" style="cursor: pointer;">
                        <img src="motor5.png" alt="Sistema ECS" class="gallery-image">
                        <div class="gallery-caption">Arquitectura ECS: Organización de entidades y componentes</div>
                    </div>
                    <div class="gallery-item" style="cursor: pointer;">
                        <img src="clouds.png" alt="Técnicas de sombreado" class="gallery-image">
                        <div class="gallery-caption">Efectos atmosféricos y nubes volumétricas</div>
                    </div>
                    <div class="gallery-item" style="cursor: pointer;">
                        <img src="skybox.png" alt="Skyboxes" class="gallery-image">
                        <div class="gallery-caption">Sistema de skyboxes dinámicos</div>
                    </div>
                    <div class="gallery-item" style="cursor: pointer;">
                        <img src="ssao.png" alt="Post-procesado" class="gallery-image">
                        <div class="gallery-caption">Efectos de post-procesado y ambient occlusion</div>
                    </div>
                </div>
            </div>
        </section>
        
        <section id="arquitectura">
            <h2>Arquitectura del Motor</h2>
            <button class="collapsible">
                <svg class="architecture-icon">
                    <use href="#window-icon"></use>
                </svg>
                <span class="icon-title">VENTANA GRÁFICA</span>
            </button>
            
            <div class="collapsible-content">
                <p style="text-align: justify; margin-top: 20px; margin-bottom: 20px;">Creación y gestión eficiente de ventanas gráficas. La inicialización comienza con la creación 
                de una instancia del sistema de motor <strong>[EngineSystem]</strong> y la configuración de los parámetros básicos de la ventana, utilizando la función estática <strong>[Window::make()]</strong> de la clase <strong>[Window]</strong>.</p>

                <p style="text-align: justify; margin-top: 20px; margin-bottom: 20px;">La funicón <strong>[Window::make()]</strong> devolverá un <strong>optional ptr</strong>, para obtener la variable de ventana necesitaremos mover su valor a una varibale de tipo <strong>[Window]</strong>.
                    Por último habrá que asociar la ventana creando un contexto en el sistema, para lograrlo es necesario utilizar <strong>[window.makeContext(system)]</strong>.</p>
                <div class="code-block">
                    <pre>
//ENGINE//---------------------------------------------------------------------------------------
EngineSystem system;

//CREAR VENTANA//--------------------------------------------------------------------------------
int windowWidth = 800;
int windowHeight = 600;
std::string window_name = "Main Window -- Terrain Demo";

auto opt_window = Window::make(windowWidth, windowHeight, window_name, system);
if (!opt_window) {
    std::cerr << "Error: Failed to create window." << std::endl;
    return -1;
}

//INICIALIZAR VENTANA//---------------------------------------------------------------------------
Window window = std::move(opt_window.value());
window.makeContext(system);</pre>
                </div>
            </div>

            <button class="collapsible">
                <svg class="architecture-icon">
                    <use href="#ui-icon"></use>
                </svg>
                <span class="icon-title">CONTROLES & INTERFAZ USUARIO</span>
            </button>
            <div class="collapsible-content">
                <p style="text-align: justify; margin-top: 20px; margin-bottom: 20px;">Para poder utilizar las funcionalidades de input, es necesario declarar un clase <strong>[Input]</strong> y asignarle la ventana
                que tiene en contexto el sistema del motor. De la misma forma con la clase <strong>[UIRenderer]</strong>. Estas variables inicialidas serán necesarias más adelante para otros subsistemas.</p>
                <div class="code-block">
                    <pre>
//INPUT//-----------------------------------------------------------------------------------------
Input input(window.getWindow());

//UI//--------------------------------------------------------------------------------------------
UIRenderer ui(window.getWindow());</pre>
                </div>
            </div>
            
            <button class="collapsible">
                <svg class="architecture-icon">
                    <use href="#camera-icon"></use>
                </svg>
                <span class="icon-title">CÁMARA PRINCIPAL</span>
            </button>
            <div class="collapsible-content">
                <p style="text-align: justify; margin-top: 20px; margin-bottom: 20px;">Creación y gestión de una variable Cámara. Para crear una variable <strong>[Camera]</strong>, es necesario, haber creado una clase <strong>[Input]</strong> previamente
                    y asignarla a la cámara junto a los demás parámetros de inicialización. Para utilizar dicha cámara como vista en la escena, será necesario asociarla al <strong>[RenderSystem]</strong>.</p>

                <p style="text-align: justify; margin-top: 20px; margin-bottom: 20px;">Por otro lado, el movimiento de Flycam puede ser activado, utilizando el método <strong>[camera.update()]</strong> en el Main Loop. 
                    Para poder desbloquear la rotación de la cámara es necesario pulsar la tecla <strong>[SHIFT]</strong> y para el movimiento normal <strong>[WASD]</strong>. La intensidad del <strong>[SSAO]</strong> se ajusta desde la cámara.</p>
                <div class="code-block">
                    <pre>
//CÁMARA//----------------------------------------------------------------------------------------
Camera camera(&input, glm::vec3(-90.0f, 150.0f, 130.0f),                // posición
                0.0f,                                                   // yaw
                -30.0f,                                                 // pitch
                75.0f,                                                  // fov (campo de visión)
                windowWidth / windowHeight,                             // relación de aspecto
                0.1f,                                                   // plano cercano
                15000.f);                                               // plano lejano

//ASOCIAR CÁMARA AL RENDER//----------------------------------------------------------------------
renderSystem.render(em, cm, "renderShader...", "skybox", camera);

//SSAO//------------------------------------------------------------------------------------------
camera.ambientOclussionStrenght = 1.0f;
            
//MOVIMIENTO CÁMARA FLYCAM//----------------------------------------------------------------------
float deltaTime = system.getDeltaTime();
camera.update(deltaTime);</pre>
                </div>
            </div>

            <button class="collapsible">
                <svg class="architecture-icon">
                    <use href="#ecs-icon"></use>
                </svg>
                <span class="icon-title">SISTEMA ECS</span>
            </button>
            <div class="collapsible-content">
                <p style="text-align: justify; margin-top: 20px; margin-bottom: 20px;">Creación y gestión de entidades. Para poder utilizar las herramientas ECS, es necesario crear una variable de tipo <strong>[EntityManager]</strong>
                y otra de tipo <strong>[ComponentManager]</strong>, la primera permitirá crear entidades y la segunda añadir/obtener componentes de dichas entidades.</p> 

                <p style="text-align: justify; margin-top: 20px; margin-bottom: 20px;">Para añadirle a una entidad una malla cargada desde el dispositivo, deberemos utilizar el método estático <strong>[MeshComponent::loadModel()]</strong>.
                Está función nos devuelve una variable <strong>[MeshData]</strong>, necesaria para la construcción de una variable de tipo malla, <strong>[MeshComponent(MeshData)]</strong>, una vez este componente esté inicializado se puede añadir a la entidad con
                la función <strong>[cm.addComponent(Entidad, &ltComponente&gt)]</strong>.</p> 
                
                
                <p style="text-align: justify; margin-top: 20px; margin-bottom: 20px;"></p>Si a una entidad se le añaden varios componentes del mismo tipo, se utilizará el último componente añadido.</p> 
                
                <p style="text-align: justify; margin-top: 20px; margin-bottom: 20px;">Es importante tener en cuenta que los componentes se deben obtener preferiblemente en el Main Loop.</p>
                <div class="code-block">
                    <pre>
//INICIALIZAR ECS//--------------------------------------------------------------------------------
EntityManager em;
ComponentManager cm;

//CREAR UNA ENTIDAD RENDERIZABLE//------------------------------------------------------------------
Entity Luffy = em.createEntity();
cm.addComponent(Luffy, ColorComponent{ glm::vec4(1.0, 1.0, 1.0, 1.0), true });
cm.addComponent(Luffy, TransformComponent{ glm::vec3(40.0f, 50.0f, -50.0f),
                                            glm::vec3(0.0f, 0.0f, 0.0f),
                                            glm::vec3(0.5f, 0.5f, 0.5f) });
cm.addComponent(Luffy, MeshComponent(MeshComponent::loadModel("../assets/obj/luffy.obj")));
cm.addComponent(Luffy, TextureComponent(TextureComponent::loadTexture("../assets/textures/luffyTexture.png")));

//OBTENER COMPONENTES DE ENTIDAD//-----------------------------------------------------------------
TransformComponent* tc = cm.getComponent&ltTransformComponent&gt(Luffy);
MeshComponent* mc = cm.getComponent&ltMeshComponent&gt(Luffy);
TextureComponent* texc = cm.getComponent&ltTextureComponent&gt(Luffy);</pre>
                </div>
            </div>

            <button class="collapsible">
                <svg class="architecture-icon">
                    <use href="#skybox-icon"></use>
                </svg>
                <span class="icon-title">SKYBOXES</span>
            </button>
            <div class="collapsible-content">
                <p style="text-align: justify; margin-top: 20px; margin-bottom: 20px;">Creación y gestión de skybox. Para poder añadir un skybox a la escena es necesario crear una variable de tipo <strong>[SkyboxManager]</strong>,
                este manager nos permitirá agregar varios skybox con el método <strong>[skyboxManager.add()]</strong>  para posteriormente seleccionar el que queramos renderizar.</p> 

                <p style="text-align: justify; margin-top: 20px; margin-bottom: 20px;">El formato aceptado por <strong>[skyboxManager.add()]</strong> es un CubeMap que se compone de 6 imagenes. <strong>Referencia:</strong> <a href="https://freestylized.com/all-skybox/" target="_blank">Freestylized Skybox Collection</a></p> 
                <div class="code-block">
                    <pre>
//SKYBOXES//----------------------------------------------------------------------------------------
SkyboxManager skyboxManager;

//SKYBOX - 0
skyboxManager.add({
    "../assets/skyboxes/sunset/px.png",  // POSITIVE_X
    "../assets/skyboxes/sunset/nx.png",  // NEGATIVE_X
    "../assets/skyboxes/sunset/py.png",  // POSITIVE_Y
    "../assets/skyboxes/sunset/ny.png",  // NEGATIVE_Y
    "../assets/skyboxes/sunset/pz.png",  // POSITIVE_Z
    "../assets/skyboxes/sunset/nz.png"   // NEGATIVE_Z
});

//SKYBOX - 1
skyboxManager.add({
    "../assets/skyboxes/day/px.png",  // POSITIVE_X
    "../assets/skyboxes/day/nx.png",  // NEGATIVE_X
    "../assets/skyboxes/day/py.png",  // POSITIVE_Y
    "../assets/skyboxes/day/ny.png",  // NEGATIVE_Y
    "../assets/skyboxes/day/pz.png",  // POSITIVE_Z
    "../assets/skyboxes/day/nz.png"   // NEGATIVE_Z
});

//RENDERIZAR SKYBOX -> 1
renderSystem.skyboxSelector = 1;

//ASOCIAR SKYBOX MANAGER AL RENDER//---------------------------------------------------------------
renderSystem.render(em, cm, "renderShader...", skyboxManager, camera);</pre>
                </div>
            </div>

            <button class="collapsible">
                <svg class="architecture-icon">
                    <use href="#terrain-icon"></use>
                </svg>
                <span class="icon-title">GENERACIÓN DE TERRENOS</span>
            </button>
            <div class="collapsible-content">
                <p style="text-align: justify; margin-top: 20px; margin-bottom: 20px;">La generación de Terrenos se divide en 3 secciones. La primera sección consiste en generar el mapa de alturas con la clase <strong>[HeightmapGenerator]</strong> y el método
                 <strong>[heightmap.generateHeightmap()]</strong>, esto generará una imagen de heightmap guardada en nuestro dispositivo, también podemos hacerlo respectivamente con el colormap del terreno 
                 utilizando <strong>[heightmap.generateColorMap()]</strong>, esto generará una textura que al asignarla al terreno dará un color por alturas.</p> 

                 <p style="text-align: justify; margin-top: 20px; margin-bottom: 20px;">La segunda sección consiste en transformar la imagen heightmap generada previamente en una malla de terreno, para lograr esta función es necesario
                    leer el archivo imagen heightmap del dispositivo y almacenarlo en una variable de tipo <strong>[TextureImage]</strong>, una vez hecho esto, al añadir un componente <strong>[Mesh]</strong> en lugar de cargar un modelo, hay que utilizar el
                    método estático <strong>[MeshComponent::loadHeightMap()]</strong>.
                 </p> 

                 <p style="text-align: justify; margin-top: 20px; margin-bottom: 20px;">La tercera y última sección consiste en generar assets distribuidos por altura y cantidad en un terreno (compatible con otros modelos 3D). Para lograr este resultado
                    se debe crear una variable <strong>[Generation]</strong> para cada iteración de generación, también se debe asociar en su inicialización una entidad que contenga un componente <strong>[Mesh]</strong>, si la entidad no contiene dicho componente la generación fallará.
                 </p> 

                <div class="code-block">
                    <pre>
//GENERADOR MAPA DE ALTURA//-----------------------------------------------------------------------
HeightmapGenerator heightmap(512, 512);
heightmap.generateHeightmap(0.01, 4, 0.4, 2.2);
heightmap.applyIslandMask(1.5);
heightmap.saveAsImage("../assets/heightmaps/heightmap.png");
std::vector&ltuint8_t&gt colorMap = heightmap.generateColorMap();
heightmap.saveColorMapAsImage("../assets/heightmaps/heightmap_colormap.png", colorMap, heightmap.width, heightmap.height);

//ENTIDAD DE TERRENO//------------------------------------------------------------------------------
TextureImage h_map_tex = TextureComponent::loadTexture("../assets/heightmaps/heightmap.png");
Entity h_map = em.createEntity();
cm.addComponent(h_map, ColorComponent{ glm::vec4(1.0f, 1.0f, 1.0f, 1.0f), true});
cm.addComponent(h_map, TransformComponent{
       glm::vec3(0.0f, 0.0f, 0.0f),
       glm::vec3(0.0f, 0.0f, 0.0f),
       glm::vec3(0.5f, 0.5f, 0.5f) });
cm.addComponent(h_map, MeshComponent(MeshComponent::loadHeightMap(h_map_tex, 620.0f, 1.0f)));
cm.addComponent(h_map, TextureComponent(TextureComponent::loadTexture("../assets/heightmaps/heightmap_colormap.png")));

//GENERACIÓN DE ASSETS EN UN TERRENO//----------------------------------------------------------------
MeshData palm = MeshComponent::loadModel("../assets/obj/palm.obj");
std::shared_ptr&ltTextureImageglt palmTexture = std::make_shared&ltTextureImage&gt(TextureComponent::loadTexture("../assets/textures/palmTexture.png"));
Generation gen(em, cm, h_map, palm, glm::vec3(3.0f, 4.0f, 3.0f), palmTexture, glm::vec2(4.0f, 11.0f),

MeshData grass = MeshComponent::loadModel("../assets/obj/grass.obj");
std::shared_ptr&ltTextureImage&gt grassTexture = std::make_shared&ltTextureImage&gt(TextureComponent::loadTexture("../assets/textures/grassTexture.png"));
Generation gen2(em, cm, h_map, grass, glm::vec3(3.0f, 7.5f, 3.0f), grassTexture, glm::vec2(16.0f, 25.0f), 70);</pre>
                </div>
            </div>

            <button class="collapsible">
                <svg class="architecture-icon">
                    <use href="#render-icon"></use>
                </svg>
                <span class="icon-title">RENDERIZADO DIFERIDO</span>
            </button>
            <div class="collapsible-content">
                <p style="text-align: justify; margin-top: 20px; margin-bottom: 20px;">Sistema de renderizado principal. Todas las entidades que tengan los siguientes componentes serán renderizadas en la escena:
                    <strong>[ColorComponent], [TransformComponent], [MeshComponent] y [TextureComponent]</strong>. Si falta algún componente mencionado anteriormente la entidad respectiva no se renderizará. 
                    Si se desea que una entidad no genere sombra, <strong>ColorComponent{ glm::vec4(1.0f, 1.0f, 1.0f, 1.0f), <strong>castShadow = false</strong>};</strong>
                </p>

                <p style="text-align: justify; margin-top: 20px; margin-bottom: 20px;">En el constructor se puede indicar si el resultado final del renderizado se volcará en la pantalla(true) o en una textura(false). En caso que sea en una textura, que es
                    la forma default, en el Main Loop se deberá utilizar la función de la clase de interfaz de usuario, <strong>[ui.renderWindow(renderSystem)]</strong> esto renderizará la escena en una ventana imgui del tamaño correspondiente.
                </p>

                <p style="text-align: justify; margin-top: 20px; margin-bottom: 20px;">El motor da soporte a los <strong>[OPE Default Shaders]</strong>, estos shaders son esenciales al momento de realizar el renderizado,
                    es posible utilizar shaders customizados pero se recomienda el uso de los nativos del motor. Estos se incluyen en la siguiente ruta: <strong>"../shaders/vertex/vsShader"</strong> y <strong>"../shaders/fragment/fsShader"</strong>.</p>
                    
                <p style="text-align: justify; margin-top: 20px; margin-bottom: 20px;">Si se desea utilizar un shader específico para calcular el albedo de una entidad, existe <strong>[CustomShaderComponent]</strong>,
                    si dicha entidad lleva este componente, el <strong>[GeometryShader]</strong> del motor será sobreescrito a la hora de renderizar dicha entidad por el shader personalizado correspondiente. El shader debe de tener
                    una estructura similiar al shader de geometría para escribir en los gBuffers adecuadamente, de lo contrario, no se trasmitirá en el resultado.</p>
                    
                    <p style="text-align: justify; margin-top: 20px; margin-bottom: 20px;"></p><strong>!!!</strong><strong>[CustomShaderComponent]</strong> se encuentra en fase de desarrollo, consultar con los desarrolladores<strong>!!!</strong></p>

                <div class="code-block">
                    <pre>
//INICIALIZAR//------------------------------------------------------------------------------------                
RenderSystem renderSystem(false, windowWidth, windowHeight);

//OPE DEFAULT SHADERS RENDER SYSTEM//--------------------------------------------------------------
std::shared_ptr&ltShader&gt geometryShader = std::make_shared&ltShader&gt("../shaders/vertex/geometrypassDeferredRendering.vs", "../shaders/fragment/geometrypassDeferredRendering.fs");
std::shared_ptr&ltShader&gt lightShader = std::make_shared&ltShader&gt("../shaders/vertex/lightpassDeferredRendering.vs", "../shaders/fragment/lightpassDeferredRendering.fs");
std::shared_ptr&ltShader&gt shadowShader = std::make_shared&ltShader&gt("../shaders/vertex/pointShadowPass.vs", "../shaders/fragment/pointShadowPass.fs", "../shaders/geometry/pointShadowPass.gs");
std::shared_ptr&ltShader&gt ssaoShader = std::make_shared&ltShader&gt("../shaders/vertex/ssaoPass.vs", "../shaders/fragment/ssaoPass.fs");
std::shared_ptr&ltShader&gt ssaoBlurShader = std::make_shared&ltShader&gt("../shaders/vertex/ssaoBlurPass.vs", "../shaders/fragment/ssaoBlurPass.fs");
std::shared_ptr&ltShader&gt skyboxShader = std::make_shared&ltShader&gt("../shaders/vertex/skybox.vs", "../shaders/fragment/skybox.fs");
std::shared_ptr&ltShader&gt cloudShader = std::make_shared&ltShader&gt("../shaders/vertex/cloudShader.vs", "../shaders/fragment/cloudShader.fs");

//MAIN LOOP//--------------------------------------------------------------------------------------  
renderSystem.render(em, cm, geometryShader, lightShader, shadowShader, ssaoShader, ssaoBlurShader, skyboxShader, cloudShader, skyboxManager, camera);

//CUSTOM GEOMETRY SHADER//------------------------------------------------------------------------------------  
std::shared_ptr&ltShader&gt oceanShader = std::make_shared&ltShader&gt("../shaders/vertex/oceanShader.vs", "../shaders/fragment/oceanShader.fs");

cm.addComponent(ocean, CustomShaderComponent(oceanShader, TextureComponent(TextureComponent::loadTexture("../assets/heightmaps/image.png")), 
                                                          TextureComponent(TextureComponent::loadTexture("../assets/normalMaps/water_normal.jpg"))));</pre>
                </div>
            </div>

            <button class="collapsible">
                <svg class="architecture-icon">
                    <use href="#loop-icon"></use>
                </svg>
                <span class="icon-title">SISTEMA DE FÍSICA</span>
            </button>
            <div class="collapsible-content">
                <p style="text-align: justify; margin-top: 20px; margin-bottom: 20px;">El sistema de física proporciona simulación de cuerpos rígidos con detección de colisiones. Para añadir propiedades físicas a una entidad, es necesario agregar un componente <strong>[PhysicsComponent]</strong> a la misma. Posteriormente, se debe registrar la entidad en el sistema de física usando <strong>[physicsSystem.addEntityToPhysics(entity, cm)]</strong>.</p>
            
                <p style="text-align: justify; margin-top: 20px; margin-bottom: 20px;">El sistema de física utiliza una estructura Octree para optimizar la detección de colisiones, permitiendo manejar grandes cantidades de objetos de manera eficiente. La detección de colisiones se realiza primero a nivel de cajas delimitadoras (AABB) y luego, si es necesario, a nivel de triángulos para mayor precisión.</p>
                
                <div class="code-block">
                    <pre>
            //INICIALIZAR SISTEMA DE FÍSICA//--------------------------------------------------------------------
            PhysicsSystem physicsSystem;
            physicsSystem.initialize();
            physicsSystem.setGravity(glm::vec3(0.0f, -9.81f, 0.0f));
            
            //AÑADIR COMPONENTE DE FÍSICA A UNA ENTIDAD//--------------------------------------------------------
            Entity cube = em.createEntity();
            cm.addComponent(cube, TransformComponent{ glm::vec3(0.0f, 10.0f, 0.0f),
                                                     glm::vec3(0.0f, 0.0f, 0.0f),
                                                     glm::vec3(1.0f, 1.0f, 1.0f) });
            cm.addComponent(cube, MeshComponent(MeshComponent::loadModel("../assets/obj/cube.obj")));
            cm.addComponent(cube, ColorComponent{ glm::vec4(1.0f, 0.0f, 0.0f, 1.0f), true });
            
            // Agregar física con propiedades personalizadas
            PhysicsComponent physComp;
            physComp.mass = 2.0f;
            physComp.restitution = 0.7f;
            physComp.friction = 0.3f;
            cm.addComponent(cube, physComp);
            
            // Registrar la entidad en el sistema de física
            physicsSystem.addEntityToPhysics(cube, cm);
            
            //CREAR SUELO ESTÁTICO//---------------------------------------------------------------------------
            Entity ground = em.createEntity();
            cm.addComponent(ground, TransformComponent{ glm::vec3(0.0f, 0.0f, 0.0f),
                                                       glm::vec3(0.0f, 0.0f, 0.0f),
                                                       glm::vec3(20.0f, 0.1f, 20.0f) });
            cm.addComponent(ground, MeshComponent(MeshComponent::loadModel("../assets/obj/plane.obj")));
            cm.addComponent(ground, ColorComponent{ glm::vec4(0.2f, 0.2f, 0.8f, 1.0f), true });
            cm.addComponent(ground, PhysicsComponent());
            
            // Registrar como objeto estático (no se mueve)
            physicsSystem.addEntityToPhysics(ground, cm, true);
            
            //MAIN LOOP//--------------------------------------------------------------------------------------
            while (window.isOpen()) {
                float deltaTime = system.getDeltaTime();
                
                // Actualizar la simulación física
                physicsSystem.update(em, cm, deltaTime);
                
                // Resto del bucle principal...
            }</pre>
                </div>
            </div>

            <button class="collapsible">
                <svg class="architecture-icon">
                    <use href="#loop-icon"></use>
                </svg>
                <span class="icon-title">PROGRAMA EJEMPLO</span>
            </button>
            <div class="collapsible-content">
                <div class="code-block">
                    <pre>
#include "ope/Window.hpp"
#include "ope/Shader.hpp"
#include "ope/Mesh.hpp"
#include "ope/Texture.hpp"
#include "ope/EngineSystem.hpp"
#include "ope/Input.hpp" 
#include "ope/Camera.hpp"
#include "ope/ECSManager.hpp"
#include "ope/Transform.hpp"
#include "ope/Render.hpp"
#include "ope/UIRenderer.hpp"
#include "ope/Components.hpp"
#include "ope/CharacterController.hpp"
#include "ope/Light.hpp"
#include "ope/Heightmap.hpp"
#include "ope/Skybox.hpp"
#include "ope/Generation.hpp"
#include "ope/GPUInstancing.hpp"

int main() {

//ENGINE//----------------------------------------------------------------------------------------
EngineSystem system;

//WINDOW//----------------------------------------------------------------------------------------
int windowWidth = 800;
int windowHeight = 600;

std::string window_name = "Main Window -- Terrain Demo";

auto opt_window = Window::make(1022, 605, window_name, system);
if (!opt_window) {
    std::cerr &lt;&lt; "Error: Failed to create window." &lt;&lt; std::endl;
    return -1;
}

Window window = std::move(opt_window.value());
window.makeContext(system);

system.disableVSync();

//INPUT//-----------------------------------------------------------------------------------------
Input input(window.getWindow());

//UI//--------------------------------------------------------------------------------------------
UIRenderer ui(window.getWindow());

//CAMERA//----------------------------------------------------------------------------------------
Camera camera(&input, glm::vec3(-90.0f, 150.0f, 130.0f),                // posición
                0.0f,                                                   // yaw
                -30.0f,                                                 // pitch
                75.0f,                                                  // fov (campo de visión)
                windowWidth / windowHeight,                             // relación de aspecto
                1.0f,                                                   // plano cercano
                15000.f);                                               // plano lejano

//SYSTEMS//----------------------------------------------------------------------------------------                       
RenderSystem renderSystem(false, windowWidth, windowHeight);

//HEIGHTMAP GENERATOR------------------------------------------------------------------------------
HeightmapGenerator heightmap(1024, 1024);
heightmap.generateHeightmap(0.005, 4, 0.4, 2.2);
heightmap.applyIslandMask(1.3);
heightmap.saveAsImage("../assets/heightmaps/a.png");
std::vector&lt;uint8_t&gt; colorMap = heightmap.generateColorMap();
heightmap.saveColorMapAsImage("../assets/heightmaps/a_colormap.png", colorMap, heightmap.width, heightmap.height);

//SKYBOX//-----------------------------------------------------------------------------------------
SkyboxManager skyboxManager;

skyboxManager.add({
    "../assets/skyboxes/sunset/px.png",  // POSITIVE_X
    "../assets/skyboxes/sunset/nx.png",  // NEGATIVE_X
    "../assets/skyboxes/sunset/py.png",  // POSITIVE_Y
    "../assets/skyboxes/sunset/ny.png",  // NEGATIVE_Y
    "../assets/skyboxes/sunset/pz.png",  // POSITIVE_Z
    "../assets/skyboxes/sunset/nz.png"   // NEGATIVE_Z
});

skyboxManager.add({
    "../assets/skyboxes/day/px.png",  // POSITIVE_X
    "../assets/skyboxes/day/nx.png",  // NEGATIVE_X
    "../assets/skyboxes/day/py.png",  // POSITIVE_Y
    "../assets/skyboxes/day/ny.png",  // NEGATIVE_Y
    "../assets/skyboxes/day/pz.png",  // POSITIVE_Z
    "../assets/skyboxes/day/nz.png"   // NEGATIVE_Z
});

skyboxManager.add({
    "../assets/skyboxes/night/px.png",  // POSITIVE_X
    "../assets/skyboxes/night/nx.png",  // NEGATIVE_X
    "../assets/skyboxes/night/py.png",  // POSITIVE_Y
    "../assets/skyboxes/night/ny.png",  // NEGATIVE_Y
    "../assets/skyboxes/night/pz.png",  // POSITIVE_Z
    "../assets/skyboxes/night/nz.png"   // NEGATIVE_Z
});

skyboxManager.add({
    "../assets/skyboxes/space/px.png",  // POSITIVE_X
    "../assets/skyboxes/space/nx.png",  // NEGATIVE_X
    "../assets/skyboxes/space/py.png",  // POSITIVE_Y
    "../assets/skyboxes/space/ny.png",  // NEGATIVE_Y
    "../assets/skyboxes/space/pz.png",  // POSITIVE_Z
    "../assets/skyboxes/space/nz.png"   // NEGATIVE_Z
});

//ECS//--------------------------------------------------------------------------------------------
EntityManager em;
ComponentManager cm;

//CUSTOM SHADER------------------------------------------------------------------------------------
std::shared_ptr&lt;Shader&gt; oceanShader = std::make_shared&lt;Shader&gt;("../shaders/vertex/oceanShader.vs", "../shaders/fragment/oceanShader.fs");

//------------//
//  ENTITIES  //
//------------//

//Terrain//----------------------------------------------------------------------------------------
TextureImage h_map_tex = TextureComponent::loadTexture("../assets/heightmaps/a.png");
Entity h_map = em.createEntity();
cm.addComponent(h_map, ColorComponent{ glm::vec4(1.0f, 1.0f, 1.0f, 1.0f), true});
cm.addComponent(h_map, TransformComponent{
        glm::vec3(0.0f, 0.0f, 0.0f),
        glm::vec3(0.0f, 0.0f, 0.0f),
        glm::vec3(0.5f, 0.5f, 0.5f)
    });
cm.addComponent(h_map, MeshComponent(MeshComponent::loadHeightMap(h_map_tex, 620.0f, 1.0f)));
cm.addComponent(h_map, TextureComponent(TextureComponent::loadTexture("../assets/heightmaps/a_colormap.png")));


//Instanced GPU//----------------------------------------------------------------------------------
MeshData meshData = MeshComponent::loadModel("../assets/obj/fern.obj");
auto instancedMesh = std::make_shared&lt;InstancedMeshComponent&gt;(meshData, 1000);

MeshData PalmMeshData = MeshComponent::loadModel("../assets/obj/palm.obj");
auto PalmInstancedMesh = std::make_shared&lt;InstancedMeshComponent&gt;(PalmMeshData, 1000);

MeshData TreeMeshData = MeshComponent::loadModel("../assets/obj/tree-tall.obj");
auto TreeInstancedMesh = std::make_shared&lt;InstancedMeshComponent&gt;(TreeMeshData, 1000);

MeshData TreeAutumMeshData = MeshComponent::loadModel("../assets/obj/tree-autumn.obj");
auto TreeAutumInstancedMesh = std::make_shared&lt;InstancedMeshComponent&gt;(TreeAutumMeshData, 1000);

Entity instancedEntity = em.createEntity();
cm.addComponent(instancedEntity, InstancedRenderComponent(instancedMesh));
cm.addComponent(instancedEntity, TextureComponent(TextureComponent::loadTexture("../assets/textures/fernTexture.jpeg")));

InstancedRenderComponent* instancedRender = cm.getComponent&lt;InstancedRenderComponent&gt;(instancedEntity);
instancedRender->instancedMesh->placeInstancesOnTerrain(
    em,
    cm,
    h_map,                                      // Entidad del terreno
    glm::vec3(0.03f, 0.03f, 0.03f),             // Escala para cada instancia
    glm::vec2(15.0f, 21.0f),                    // Rango de altura (min, max)
    700                                         // Número total de instancias
);
//--------------------------------------------------------------------------------------------------
Entity instancedEntityPalms = em.createEntity();
cm.addComponent(instancedEntityPalms, InstancedRenderComponent(PalmInstancedMesh));
cm.addComponent(instancedEntityPalms, TextureComponent(TextureComponent::loadTexture("../assets/textures/colormap.png")));

InstancedRenderComponent* instancedRenderPalm = cm.getComponent&lt;InstancedRenderComponent&gt;(instancedEntityPalms);
instancedRenderPalm->instancedMesh->placeInstancesOnTerrain(
    em,
    cm,
    h_map,                                      // Entidad del terreno
    glm::vec3(3.0f, 4.0f, 3.0f),                // Escala para cada instancia
    glm::vec2(3.0f, 18.0f),                     // Rango de altura (min, max)
    75                                          // Número total de instancias
);
//--------------------------------------------------------------------------------------------------
Entity instancedEntityTrees = em.createEntity();
cm.addComponent(instancedEntityTrees, InstancedRenderComponent(TreeInstancedMesh));
cm.addComponent(instancedEntityTrees, TextureComponent(TextureComponent::loadTexture("../assets/textures/colormap2.png")));

InstancedRenderComponent* instancedRenderTree = cm.getComponent&lt;InstancedRenderComponent&gt;(instancedEntityTrees);
instancedRenderTree->instancedMesh->placeInstancesOnTerrain(
    em,
    cm,
    h_map,                                      // Entidad del terreno
    glm::vec3(11.0f, 11.0f, 11.0f),             // Escala para cada instancia
    glm::vec2(20.0f, 60.0f),                    // Rango de altura (min, max)
    150                                         // Número total de instancias
);
//--------------------------------------------------------------------------------------------------
Entity instancedEntityTreesAutum = em.createEntity();
cm.addComponent(instancedEntityTreesAutum, InstancedRenderComponent(TreeAutumInstancedMesh));
cm.addComponent(instancedEntityTreesAutum, TextureComponent(TextureComponent::loadTexture("../assets/textures/colormap2.png")));

InstancedRenderComponent* instancedRenderTreeAutum = cm.getComponent&lt;InstancedRenderComponent&gt;(instancedEntityTreesAutum);
instancedRenderTreeAutum->instancedMesh->placeInstancesOnTerrain(
    em,
    cm,
    h_map,                                       // Entidad del terreno
    glm::vec3(11.0f, 11.0f, 11.0f),              // Escala para cada instancia
    glm::vec2(30.0f, 80.0f),                     // Rango de altura (min, max)
    150                                          // Número total de instancias
);

//Cube//-------------------------------------------------------------------------------------------
Entity cube = em.createEntity();
cm.addComponent(cube, ColorComponent{ glm::vec4(0.0f, 0.3f, 0.8f, 1.0f), false });
cm.addComponent(cube, TransformComponent{
        glm::vec3(256.0f, -52.0f, 256.0f),
        glm::vec3(0.0f, 0.0f, 0.0f),
        glm::vec3(256.0f, 50.0f, 256.0f)
    });
cm.addComponent(cube, MeshComponent(MeshComponent::loadModel("../assets/obj/cube.obj")));
cm.addComponent(cube, TextureComponent(TextureComponent::loadTexture("../assets/textures/whiteTexture.png")));

//Light//-----------------------------------------------------------------------------------------
Entity light = em.createEntity();
cm.addComponent(light, ColorComponent{ glm::vec4(1.0f, 0.0f, 0.0f, 1.0f), false });
cm.addComponent(light, TransformComponent{ glm::vec3(250.0f, 250.0f, 150.0f),
                                            glm::vec3(0.0f, 0.0f, 0.0f),
                                            glm::vec3(1.0f, 1.0f, 1.0f) });

cm.addComponent(light, LightComponent(LightComponent::LightType::Point,             // Light type
                                            glm::vec3(0.5, -1.0f, 0.5f),            // direction
                                            glm::vec3(0.5f, 0.5f, 0.5f),            // ambient
                                            glm::vec3(1.0f, 1.0f, 1.0f),            // diffuse
                                            glm::vec3(0.05f, 0.05f, 0.05f),         // specular
                                            1.0f, 0.045f, 0.0075f,                  // attenuation constants
                                            1.0, 0.95f,                             // cutoff angles
                                            1.0f, 500.0f, 0.0001f));                // strenght, distance, bias
//Ocean//-----------------------------------------------------------------------------------------
Entity ocean = em.createEntity();
cm.addComponent(ocean, ColorComponent{ glm::vec4(0.0f, 0.3f, 0.8f, 1.0f), false });
cm.addComponent(ocean, TransformComponent{
        glm::vec3(256.0f, 2.0f, 256.0f),
        glm::vec3(0.0f, 0.0f, 0.0f),
        glm::vec3(256.0f, 1.0f, 256.0f)
    });
cm.addComponent(ocean, MeshComponent(MeshComponent::loadModel("../assets/ocean/ocean_plane.obj")));
cm.addComponent(ocean, TextureComponent(TextureComponent::loadTexture("../assets/textures/water.png")));
cm.addComponent(ocean, CustomShaderComponent(oceanShader, TextureComponent(TextureComponent::loadTexture("../assets/textures/water.png")),
    TextureComponent(TextureComponent::loadTexture("../assets/normalMaps/water_normal.jpg"))));

//GENERATION//------------------------------------------------------------------------------------
MeshData lightHouse = MeshComponent::loadModel("../assets/obj/LightHouse.obj");
std::shared_ptr&lt;TextureImage&gt; lightHouseTexture = std::make_shared&lt;TextureImage&gt;(TextureComponent::loadTexture("../assets/textures/LightHouseTexture.png"));
Generation genLightHouse(em, cm, h_map, lightHouse, glm::vec3(0.5f, 0.6f, 0.5f), lightHouseTexture, glm::vec2(10.0f, 15.0f), 1);

//------------//
//  SHADERS   //
//------------//

//SHADERS RENDER SYSTEM//---------------------------------------------------------------------------------------
std::shared_ptr&lt;Shader&gt; geometryShader = std::make_shared&lt;Shader&gt;("../shaders/vertex/geometrypassDeferredRendering.vs", "../shaders/fragment/geometrypassDeferredRendering.fs");
std::shared_ptr&lt;Shader&gt; lightShader = std::make_shared&lt;Shader&gt;("../shaders/vertex/lightpassDeferredRendering.vs", "../shaders/fragment/lightpassDeferredRendering.fs");
std::shared_ptr&lt;Shader&gt; pointShadowShader = std::make_shared&lt;Shader&gt;("../shaders/vertex/pointShadowPass.vs", "../shaders/fragment/pointShadowPass.fs", "../shaders/geometry/pointShadowPass.gs");
std::shared_ptr&lt;Shader&gt; spotShadowShader = std::make_shared&lt;Shader&gt;("../shaders/vertex/spotShadowPass.vs", "../shaders/fragment/spotShadowPass.fs");
std::shared_ptr&lt;Shader&gt; directionalShadowShader = std::make_shared&lt;Shader&gt;("../shaders/vertex/directionalShadowPass.vs", "../shaders/fragment/directionalShadowPass.fs");
std::shared_ptr&lt;Shader&gt; ssaoShader = std::make_shared&lt;Shader&gt;("../shaders/vertex/ssaoPass.vs", "../shaders/fragment/ssaoPass.fs");
std::shared_ptr&lt;Shader&gt; ssaoBlurShader = std::make_shared&lt;Shader&gt;("../shaders/vertex/ssaoBlurPass.vs", "../shaders/fragment/ssaoBlurPass.fs");
std::shared_ptr&lt;Shader&gt; skyboxShader = std::make_shared&lt;Shader&gt;("../shaders/vertex/skybox.vs", "../shaders/fragment/skybox.fs");
std::shared_ptr&lt;Shader&gt; cloudShader = std::make_shared&lt;Shader&gt;("../shaders/vertex/cloudShader.vs", "../shaders/fragment/cloudShader.fs");
std::shared_ptr&lt;Shader&gt; instancedShader = std::make_shared&lt;Shader&gt;("../shaders/vertex/instancedGeometryPass.vs", "../shaders/fragment/instancedGeometryPass.fs");
std::shared_ptr&lt;Shader&gt; instancedPointShadowShader = std::make_shared&lt;Shader&gt;("../shaders/vertex/instancedPointShadow.vs", "../shaders/fragment/instancedPointShadow.fs", "../shaders/geometry/instancedPointShadow.gs");


//--------------//
//   MAIN LOOP  //
//--------------//

while (window.isOpen()) {

    window.clear(0.0f, 0.0f, 0.0f, 1.0f);

    float deltaTime = system.getDeltaTime();

    //INPUT---------------------------
    input.updateKeyStates();

    //CAMERA--------------------------
    camera.update(deltaTime);

    //UPDATE--------------------------
    TransformComponent* tc = cm.getComponent&lt;TransformComponent&gt;(light);
    LightComponent* lc = cm.getComponent&lt;LightComponent&gt;(light);
    ColorComponent* cc = cm.getComponent&lt;ColorComponent&gt;(h_map);

    renderSystem.render(em, cm, geometryShader, lightShader, 
                        pointShadowShader, spotShadowShader, directionalShadowShader,
                        ssaoShader, ssaoBlurShader,
                        skyboxShader, cloudShader, 
                        instancedShader, instancedPointShadowShader,
                        skyboxManager, 
                        camera);

    //HUD-----------------------------
    ui.newFrame();

    //RENDER-----------------------------
    ui.renderWindow(renderSystem); // If the scene is rendered in a Texture

    ui.entityViewer(em);
    ui.renderTextureWindow(cm.getComponent&lt;TextureComponent&gt;(h_map)->ID);
    ui.settingsWindow(camera, lc, renderSystem, renderSystem.textureType, renderSystem.bSkybox, renderSystem.skyboxSelector, renderSystem.bClouds);

    ImGui::Begin("FPS");
    ImGui::Text("FPS: %.2f", system.displayFPS());
    ImGui::End();

    ui.endFrame();

    window.swapBuffers();
    window.pollEvents();
}

return 0;
}</pre>
                </div>
            </div>

        </section>
            
        <section id="api">
            <h2>Referencia de API</h2>

            <div class="search-container">
                <input type="text" id="apiSearchInput" class="api-search-input" placeholder="Buscar en la API...">
                <button id="apiSearchClear" class="api-search-clear" title="Limpiar búsqueda">×</button>
            </div>

            <table class="api-table">
                <tr>
                    <th>Clase/Función</th>
                    <th>Descripción</th>
                </tr>

                <tr class="expandable-row" onclick="toggleDetails('aabb')">
                    <td>AABB</td>
                    <td>Estructura para representar una caja delimitadora alineada con los ejes</td>
                </tr>
                <tr id="aabb" class="details-row">
                    <td colspan="2">
                        <div class="details-content">
                            <h3>Variables:</h3>
                            <ul>
                                <li><code>min</code> - Vector 3D con las coordenadas mínimas de la caja</li>
                                <li><code>max</code> - Vector 3D con las coordenadas máximas de la caja</li>
                            </ul>
                            <h3>Métodos:</h3>
                            <ul>
                                <li><code>AABB()</code> - Constructor por defecto</li>
                                <li><code>AABB(min, max)</code> - Constructor con puntos mínimo y máximo</li>
                                <li><code>intersects(other)</code> - Verifica intersección con otra AABB</li>
                                <li><code>getCenter()</code> - Obtiene el centro de la caja</li>
                                <li><code>getDimensions()</code> - Obtiene las dimensiones de la caja</li>
                                <li><code>transform(transform)</code> - Aplica una transformación a la AABB</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <tr class="expandable-row" onclick="toggleDetails('branching')">
                    <td>Branching</td>
                    <td>Estructura para gestión de ramas de audio</td>
                </tr>
                <tr id="branching" class="details-row">
                    <td colspan="2">
                        <div class="details-content">
                            <h3>Variables:</h3>
                            <ul>
                                <li><code>state</code> - Estado actual de la rama</li>
                                <li><code>branching_state</code> - Estado de ramificación</li>
                                <li><code>branching_interp_state</code> - Estado de interpolación</li>
                                <li><code>branching_interp_buffer_index</code> - Índice del buffer de interpolación</li>
                                <li><code>interpolate</code> - Si se debe interpolar entre estados</li>
                                <li><code>playbranching</code> - Si se debe reproducir la ramificación</li>
                                <li><code>initplaybranching</code> - Inicialización de la reproducción</li>
                                <li><code>sourceForBranching</code> - Fuente de audio para ramificación</li>
                                <li><code>buffersProcessed</code> - Buffers procesados</li>
                                <li><code>currentBufferIndex</code> - Índice del buffer actual</li>
                                <li><code>nextBufferIndex</code> - Índice del siguiente buffer</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <tr class="expandable-row" onclick="toggleDetails('camera')">
                    <td>Camera</td>
                    <td>Maneja la vista y proyección en la escena 3D</td>
                </tr>
                <tr id="camera" class="details-row">
                    <td colspan="2">
                        <div class="details-content">
                            <h3>Variables:</h3>
                            <ul>
                                <li><code>position</code> - Posición de la cámara en el espacio 3D</li>
                                <li><code>front</code> - Vector dirección hacia donde mira la cámara</li>
                                <li><code>up</code> - Vector "arriba" de la cámara</li>
                                <li><code>right</code> - Vector perpendicular a front y up</li>
                                <li><code>worldUp</code> - Vector global "arriba"</li>
                                <li><code>yaw</code> - Rotación en el eje Y (horizontal)</li>
                                <li><code>pitch</code> - Rotación en el eje X (vertical)</li>
                                <li><code>fov</code> - Campo de visión en grados</li>
                                <li><code>aspectRatio</code> - Relación de aspecto de la pantalla</li>
                                <li><code>nearPlane</code> - Plano cercano de recorte</li>
                                <li><code>farPlane</code> - Plano lejano de recorte</li>
                                <li><code>cameraSpeed</code> - Velocidad de movimiento</li>
                                <li><code>mouseSensitivity</code> - Sensibilidad del ratón</li>
                                <li><code>ambientOclussionStrenght</code> - Intensidad del SSAO</li>
                            </ul>
                            <h3>Métodos:</h3>
                            <ul>
                                <li><code>Camera(input, position, yaw, pitch, fov, aspectRatio, nearPlane, farPlane)</code> - Constructor</li>
                                <li><code>getViewMatrix()</code> - Obtiene la matriz de vista</li>
                                <li><code>getProjectionMatrix()</code> - Obtiene la matriz de proyección</li>
                                <li><code>move(direction, delta)</code> - Mueve la cámara en una dirección</li>
                                <li><code>rotate(deltaYaw, deltaPitch)</code> - Rota la cámara</li>
                                <li><code>update(delta)</code> - Actualiza la cámara según input</li>
                                <li><code>getPosition()</code> - Obtiene la posición actual</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <tr class="expandable-row" onclick="toggleDetails('characterController')">
                    <td>CharacterController</td>
                    <td>Controla el movimiento de personajes</td>
                </tr>
                <tr id="characterController" class="details-row">
                    <td colspan="2">
                        <div class="details-content">
                            <h3>Variables:</h3>
                            <ul>
                                <li><code>entity</code> - Entidad asociada al controlador</li>
                                <li><code>input</code> - Puntero al sistema de entrada</li>
                                <li><code>componentManager</code> - Puntero al gestor de componentes</li>
                                <li><code>transform</code> - Puntero al componente de transformación</li>
                            </ul>
                            <h3>Métodos:</h3>
                            <ul>
                                <li><code>CharacterController(entity, cm, input)</code> - Constructor</li>
                                <li><code>move()</code> - Mueve el personaje según el input</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <tr class="expandable-row" onclick="toggleDetails('colorComponent')">
                    <td>ColorComponent</td>
                    <td>Componente para almacenar información de color</td>
                </tr>
                <tr id="colorComponent" class="details-row">
                    <td colspan="2">
                        <div class="details-content">
                            <h3>Variables:</h3>
                            <ul>
                                <li><code>value</code> - Vector de color RGBA</li>
                                <li><code>castShadow</code> - Si el objeto proyecta sombras</li>
                            </ul>
                            <h3>Métodos:</h3>
                            <ul>
                                <li><code>ColorComponent()</code> - Constructor por defecto (blanco)</li>
                                <li><code>ColorComponent(v, castShadow)</code> - Constructor con valores</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <tr class="expandable-row" onclick="toggleDetails('componentManager')">
                    <td>ComponentManager</td>
                    <td>Gestiona los componentes asociados a entidades</td>
                </tr>
                <tr id="componentManager" class="details-row">
                    <td colspan="2">
                        <div class="details-content">
                            <h3>Variables:</h3>
                            <ul>
                                <li><code>componentPools</code> - Mapa de pools de componentes por tipo</li>
                            </ul>
                            <h3>Métodos:</h3>
                            <ul>
                                <li><code>addComponent(entity, component)</code> - Añade un componente a una entidad</li>
                                <li><code>getComponent&lt;T&gt;(entity)</code> - Obtiene un componente específico de una entidad</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <tr class="expandable-row" onclick="toggleDetails('customShaderComponent')">
                    <td>CustomShaderComponent</td>
                    <td>Componente para shaders personalizados</td>
                </tr>
                <tr id="customShaderComponent" class="details-row">
                    <td colspan="2">
                        <div class="details-content">
                            <h3>Variables:</h3>
                            <ul>
                                <li><code>shader</code> - Puntero compartido al shader</li>
                                <li><code>texture1</code> - Primera textura para el shader</li>
                                <li><code>texture2</code> - Segunda textura para el shader</li>
                            </ul>
                            <h3>Métodos:</h3>
                            <ul>
                                <li><code>CustomShaderComponent(shaderPtr, texture1, texture2)</code> - Constructor</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <tr class="expandable-row" onclick="toggleDetails('engineSystem')">
                    <td>EngineSystem</td>
                    <td>Sistema principal del motor gráfico</td>
                </tr>
                <tr id="engineSystem" class="details-row">
                    <td colspan="2">
                        <div class="details-content">
                            <h3>Variables:</h3>
                            <ul>
                                <li><code>lastFrameTime</code> - Tiempo del último frame</li>
                                <li><code>frameCount</code> - Contador de frames</li>
                                <li><code>lastFPSUpdateTime</code> - Último tiempo de actualización de FPS</li>
                                <li><code>fps</code> - Frames por segundo</li>
                                <li><code>time</code> - Tiempo transcurrido</li>
                            </ul>
                            <h3>Métodos:</h3>
                            <ul>
                                <li><code>EngineSystem()</code> - Constructor</li>
                                <li><code>initialize(window)</code> - Inicializa el sistema con una ventana</li>
                                <li><code>enableVSync()</code> - Activa la sincronización vertical</li>
                                <li><code>disableVSync()</code> - Desactiva la sincronización vertical</li>
                                <li><code>getTime()</code> - Obtiene el tiempo actual</li>
                                <li><code>getDeltaTime()</code> - Obtiene el tiempo entre frames</li>
                                <li><code>getRandomNumber(min, max)</code> - Genera un número aleatorio</li>
                                <li><code>getRandomColorRGBA()</code> - Genera un color aleatorio</li>
                                <li><code>displayFPS()</code> - Muestra y calcula los FPS</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <tr class="expandable-row" onclick="toggleDetails('entityManager')">
                    <td>EntityManager</td>
                    <td>Sistema de gestión de entidades del patrón ECS</td>
                </tr>
                <tr id="entityManager" class="details-row">
                    <td colspan="2">
                        <div class="details-content">
                            <h3>Variables:</h3>
                            <ul>
                                <li><code>entityCount</code> - Contador de entidades creadas</li>
                            </ul>
                            <h3>Métodos:</h3>
                            <ul>
                                <li><code>createEntity()</code> - Crea y devuelve un identificador de entidad</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <tr class="expandable-row" onclick="toggleDetails('forwardRenderSystem')">
                    <td>ForwardRenderSystem</td>
                    <td>Sistema de renderizado forward</td>
                </tr>
                <tr id="forwardRenderSystem" class="details-row">
                    <td colspan="2">
                        <div class="details-content">
                            <h3>Variables:</h3>
                            <ul>
                                <li><code>shadowMapFBO</code> - Framebuffer para mapa de sombras</li>
                                <li><code>shadowMap</code> - Textura de mapa de sombras</li>
                                <li><code>shadowCubeFBO</code> - Framebuffer para mapa de sombras cúbico</li>
                                <li><code>shadowCubeMap</code> - Textura de sombra cúbica</li>
                                <li><code>spotShadowFBO</code> - Framebuffer para sombras de foco</li>
                                <li><code>spotShadowMap</code> - Mapa de sombras para luces de foco</li>
                                <li><code>SHADOW_WIDTH</code>, <code>SHADOW_HEIGHT</code> - Resolución de mapas de sombras</li>
                                <li><code>quadVAO</code>, <code>quadVBO</code> - Buffers para el quad de renderizado</li>
                                <li><code>windowWidth</code>, <code>windowHeight</code> - Dimensiones de la ventana</li>
                                <li><code>bSkybox</code> - Activa/desactiva el skybox</li>
                                <li><code>skyboxSelector</code> - Selector de skybox</li>
                                <li><code>near_plane</code>, <code>far_plane</code> - Planos de recorte para sombras</li>
                                <li><code>cutOff</code> - Ángulo de corte para luces de foco</li>
                            </ul>
                            <h3>Métodos:</h3>
                            <ul>
                                <li><code>ForwardRenderSystem(windowWidth, windowHeight)</code> - Constructor</li>
                                <li><code>~ForwardRenderSystem()</code> - Destructor que libera los recursos de OpenGL</li>
                                <li><code>forwardRender(em, componentManager, lightShader, shadowShader, camera, lightSpaceMatrix, skyboxShader, skyboxManager)</code> - Renderiza la escena</li>
                                <li><code>renderEntities(em, componentManager, shader, colorVector)</code> - Método privado que renderiza las entidades con los componentes necesarios</li>
                                <li><code>GetLightSpaceMatrix(lightPos, lightType, lightDirection)</code> - Obtiene la matriz de luz</li>
                                <li><code>CreatePointShadowMap(resolution)</code> - Crea un mapa de sombras cúbico</li>
                                <li><code>CreateSpotLightShadowMap()</code> - Crea mapa de sombras para spotlight</li>
                                <li><code>CreateDirectionalShadowMap()</code> - Configura el mapa de sombras para luces direccionales</li>
                            </ul>
                            </ul>
                        </div>
                    </td>
                </tr>

                <tr class="expandable-row" onclick="toggleDetails('generation')">
                    <td>Generation</td>
                    <td>Distribuye assets en un terreno según altura</td>
                </tr>
                <tr id="generation" class="details-row">
                    <td colspan="2">
                        <div class="details-content">
                            <h3>Métodos:</h3>
                            <ul>
                                <li><code>Generation(em, cm, entity, asset, scale, texture, heightRange, totalAssets)</code> - Constructor que distribuye los assets</li>
                                <li><code>selectVerticesByCount(vertices, totalAssets)</code> - Selecciona vértices para colocar assets</li>
                                <li><code>placeAssetAtPoint(em, cm, asset, scale, texture, point)</code> - Coloca un asset en la posición indicada</li>
                                <li><code>getRandomNumber(min, max)</code> - Genera un número aleatorio en un rango</li>
                            </ul>
                        </div>
                    </td>
                </tr> 
                
                <tr class="expandable-row" onclick="toggleDetails('glManager')">
                    <td>GLManager</td>
                    <td>Administrador básico de OpenGL</td>
                </tr>
                <tr id="glManager" class="details-row">
                    <td colspan="2">
                        <div class="details-content">
                            <h3>Métodos:</h3>
                            <ul>
                                <li><code>GLManager()</code> - Constructor</li>
                                <li><code>defaultView()</code> - Establece la vista por defecto</li>
                                <li><code>drawTriangle(centerX, centerY, size, rotationAngle)</code> - Dibuja un triángulo</li>
                                <li><code>~GLManager()</code> - Destructor</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <tr class="expandable-row" onclick="toggleDetails('heightmapGenerator')">
                    <td>HeightmapGenerator</td>
                    <td>Genera mapas de altura para terrenos</td>
                </tr>
                <tr id="heightmapGenerator" class="details-row">
                    <td colspan="2">
                        <div class="details-content">
                            <h3>Variables:</h3>
                            <ul>
                                <li><code>width</code>, <code>height</code> - Dimensiones del mapa de altura</li>
                                <li><code>data</code> - Datos del mapa de altura</li>
                            </ul>
                            <h3>Métodos:</h3>
                            <ul>
                                <li><code>HeightmapGenerator(width, height)</code> - Constructor</li>
                                <li><code>generateHeightmap(scale, octaves, persistence, lacunarity)</code> - Genera un mapa de altura con ruido Perlin</li>
                                <li><code>applyIslandMask(islandFactor)</code> - Aplica una máscara para crear islas</li>
                                <li><code>generateColorMap()</code> - Genera un mapa de color basado en altura</li>
                                <li><code>saveAsImage(filename)</code> - Guarda el mapa de altura como imagen</li>
                                <li><code>saveColorMapAsImage(filename, colorMap, width, height)</code> - Guarda el mapa de color como imagen</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <tr class="expandable-row" onclick="toggleDetails('input')">
                    <td>Input</td>
                    <td>Sistema de entrada para teclado y ratón</td>
                </tr>
                <tr id="input" class="details-row">
                    <td colspan="2">
                        <div class="details-content">
                            <h3>Variables:</h3>
                            <ul>
                                <li><code>keys</code> - Mapa de teclas asignadas</li>
                                <li><code>window_</code> - Puntero a la ventana GLFW</li>
                                <li><code>keyStates</code> - Estados actuales de las teclas</li>
                                <li><code>previousKeyStates</code> - Estados previos de las teclas</li>
                            </ul>
                            <h3>Métodos:</h3>
                            <ul>
                                <li><code>Input(window)</code> - Constructor</li>
                                <li><code>isKeyUp(action)</code> - Verifica si una tecla está sin pulsar</li>
                                <li><code>isKeyDown(action)</code> - Verifica si una tecla está pulsada</li>
                                <li><code>isKeyPressed(action)</code> - Verifica si una tecla se acaba de pulsar</li>
                                <li><code>isKeyReleased(action)</code> - Verifica si una tecla se acaba de soltar</li>
                                <li><code>assign(Keys, action)</code> - Asigna una tecla a una acción</li>
                                <li><code>updateKeyStates()</code> - Actualiza el estado de las teclas</li>
                                <li><code>key_callback(key, scancode, action, mods)</code> - Callback para eventos de teclado</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <tr class="expandable-row" onclick="toggleDetails('jobSystem')">
                    <td>JobSystem</td>
                    <td>Sistema de trabajos paralelos</td>
                </tr>
                <tr id="jobSystem" class="details-row">
                    <td colspan="2">
                        <div class="details-content">
                            <h3>Variables:</h3>
                            <ul>
                                <li><code>mutex_</code> - Mutex para sincronización</li>
                                <li><code>tasks_</code> - Cola de tareas pendientes</li>
                                <li><code>worker_update_</code> - Variable de condición para notificar a los trabajadores</li>
                                <li><code>quit_</code> - Flag para señalar finalización</li>
                                <li><code>workers_</code> - Vector de hilos trabajadores</li>
                            </ul>
                            <h3>Métodos:</h3>
                            <ul>
                                <li><code>JobSystem()</code> - Constructor</li>
                                <li><code>~JobSystem()</code> - Destructor</li>
                                <li><code>add_task(f, args...)</code> - Añade una tarea a la cola</li>
                                <li><code>add_implementation(f)</code> - Implementación interna para añadir tareas</li>
                                <li><code>run_tasks()</code> - Ejecuta las tareas pendientes</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <tr class="expandable-row" onclick="toggleDetails('lightComponent')">
                    <td>LightComponent</td>
                    <td>Componente para fuentes de luz en la escena</td>
                </tr>
                <tr id="lightComponent" class="details-row">
                    <td colspan="2">
                        <div class="details-content">
                            <h3>Variables:</h3>
                            <ul>
                                <li><code>type</code> - Tipo de luz (Point, Directional, Spot)</li>
                                <li><code>direction</code> - Dirección de la luz</li>
                                <li><code>ambient</code> - Color/intensidad de luz ambiental</li>
                                <li><code>diffuse</code> - Color/intensidad de luz difusa</li>
                                <li><code>specular</code> - Color/intensidad de luz especular</li>
                                <li><code>constant</code>, <code>linear</code>, <code>quadratic</code> - Factores de atenuación</li>
                                <li><code>cutOff</code>, <code>outerCutOff</code> - Ángulos para luces de tipo spot</li>
                                <li><code>strength</code> - Intensidad general de la luz</li>
                                <li><code>bias</code> - Corrección para sombras</li>
                                <li><code>maxDistance</code> - Distancia máxima de influencia</li>
                            </ul>
                            <h3>Métodos:</h3>
                            <ul>
                                <li><code>LightComponent(lightType, dir, amb, diff, spec, cons, lin, quad, cut, outerCut, strength, maxDistance, bias)</code> - Constructor</li>
                                <li><code>~LightComponent()</code> - Destructor</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <tr class="expandable-row" onclick="toggleDetails('meshComponent')">
                    <td>MeshComponent</td>
                    <td>Componente que contiene la geometría 3D de un objeto</td>
                </tr>
                <tr id="meshComponent" class="details-row">
                    <td colspan="2">
                        <div class="details-content">
                            <h3>Variables:</h3>
                            <ul>
                                <li><code>vertices</code> - Vector de vértices</li>
                                <li><code>indices</code> - Vector de índices</li>
                                <li><code>VAO</code>, <code>VBO</code>, <code>EBO</code> - Identificadores de OpenGL</li>
                            </ul>
                            <h3>Métodos:</h3>
                            <ul>
                                <li><code>MeshComponent(data)</code> - Constructor</li>
                                <li><code>~MeshComponent()</code> - Destructor</li>
                                <li><code>Draw(shader, view, projection)</code> - Dibuja la malla</li>
                                <li><code>setupMesh()</code> - Configura los buffers en GPU</li>
                                <li><code>loadModel(path)</code> - Carga un modelo desde archivo OBJ</li>
                                <li><code>loadHeightMap(heightmap, scaleY, uvScale)</code> - Genera terreno desde mapa de altura</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <tr class="expandable-row" onclick="toggleDetails('octreeNode')">
                    <td>OctreeNode</td>
                    <td>Nodo de un Octree para optimizar la detección de colisiones espaciales</td>
                </tr>
                <tr id="octreeNode" class="details-row">
                    <td colspan="2">
                        <div class="details-content">
                            <h3>Variables:</h3>
                            <ul>
                                <li><code>bounds</code> - Límites del nodo (AABB)</li>
                                <li><code>depth</code> - Profundidad del nodo en el árbol</li>
                                <li><code>MAX_DEPTH</code> - Profundidad máxima del Octree (8)</li>
                                <li><code>MAX_ENTITIES_PER_NODE</code> - Entidades máximas por nodo (16)</li>
                                <li><code>entities</code> - Entidades almacenadas en este nodo</li>
                                <li><code>children</code> - Nodos hijos (8 o ninguno)</li>
                            </ul>
                            <h3>Métodos:</h3>
                            <ul>
                                <li><code>OctreeNode(bounds, depth)</code> - Constructor</li>
                                <li><code>insert(entity, aabb)</code> - Inserta una entidad con su AABB</li>
                                <li><code>queryPotentialCollisions(entity, aabb)</code> - Consulta colisiones potenciales</li>
                                <li><code>clear()</code> - Limpia el Octree</li>
                                <li><code>subdivide()</code> - Divide este nodo en 8 nodos hijos</li>
                                <li><code>getChildIndexForAABB(aabb)</code> - Determina el nodo hijo para una AABB</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <tr class="expandable-row" onclick="toggleDetails('perlinNoise')">
                    <td>PerlinNoise</td>
                    <td>Generador de ruido Perlin para terrenos</td>
                </tr>
                <tr id="perlinNoise" class="details-row">
                    <td colspan="2">
                        <div class="details-content">
                            <h3>Variables:</h3>
                            <ul>
                                <li><code>perm</code> - Vector de permutaciones para el ruido</li>
                            </ul>
                            <h3>Métodos:</h3>
                            <ul>
                                <li><code>PerlinNoise(seed)</code> - Constructor con semilla aleatoria</li>
                                <li><code>noise(x, y, z)</code> - Genera valor de ruido para una coordenada 3D</li>
                                <li><code>fade(t)</code> - Función de interpolación suavizada</li>
                                <li><code>lerp(t, a, b)</code> - Interpolación lineal</li>
                                <li><code>grad(hash, x, y, z)</code> - Función de gradiente</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <tr class="expandable-row" onclick="toggleDetails('physicsComponent')">
                    <td>PhysicsComponent</td>
                    <td>Componente para manejar propiedades físicas de entidades</td>
                </tr>
                <tr id="physicsComponent" class="details-row">
                    <td colspan="2">
                        <div class="details-content">
                            <h3>Variables de traslación:</h3>
                            <ul>
                                <li><code>velocity</code> - Velocidad actual del objeto</li>
                                <li><code>prevPosition</code> - Posición anterior (para integración de Verlet)</li>
                                <li><code>acceleration</code> - Aceleración actual</li>
                            </ul>
                            <h3>Propiedades físicas:</h3>
                            <ul>
                                <li><code>mass</code> - Masa del objeto</li>
                                <li><code>inverseMass</code> - Inversa de la masa (para cálculos de colisión)</li>
                                <li><code>restitution</code> - Coeficiente de restitución (elasticidad)</li>
                                <li><code>friction</code> - Coeficiente de fricción</li>
                                <li><code>isStatic</code> - Si es true, el objeto no se mueve pero colisiona</li>
                                <li><code>useGravity</code> - Si es true, se aplica gravedad al objeto</li>
                            </ul>
                            <h3>Propiedades de colisión:</h3>
                            <ul>
                                <li><code>boundingBox</code> - Caja delimitadora (AABB) para detección de colisiones</li>
                                <li><code>triangles</code> - Triángulos para colisiones precisas</li>
                            </ul>
                            <h3>Propiedades de rotación:</h3>
                            <ul>
                                <li><code>angularVelocity</code> - Velocidad angular (radianes/segundo)</li>
                                <li><code>torque</code> - Torque aplicado al objeto</li>
                                <li><code>orientation</code> - Orientación actual (quaternion)</li>
                                <li><code>prevOrientation</code> - Orientación anterior</li>
                                <li><code>inertiaTensor</code> - Tensor de inercia en espacio de modelo</li>
                                <li><code>inverseInertiaTensor</code> - Inverso del tensor de inercia</li>
                            </ul>
                            <h3>Métodos:</h3>
                            <ul>
                                <li><code>PhysicsComponent()</code> - Constructor que inicializa todas las propiedades</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <tr class="expandable-row" onclick="toggleDetails('physicsSystem')">
                    <td>PhysicsSystem</td>
                    <td>Sistema que maneja la simulación física y detección de colisiones</td>
                </tr>
                <tr id="physicsSystem" class="details-row">
                    <td colspan="2">
                        <div class="details-content">
                            <h3>Variables:</h3>
                            <ul>
                                <li><code>octree</code> - Octree para optimizar la detección de colisiones</li>
                                <li><code>gravity</code> - Vector de gravedad para el mundo</li>
                                <li><code>fixedTimeStep</code> - Paso de tiempo fijo para la simulación</li>
                            </ul>
                            <h3>Métodos públicos:</h3>
                            <ul>
                                <li><code>PhysicsSystem()</code> - Constructor</li>
                                <li><code>initialize()</code> - Inicializa el sistema de física</li>
                                <li><code>update(em, cm, deltaTime)</code> - Actualiza la simulación de física</li>
                                <li><code>addEntityToPhysics(entity, cm, isStatic)</code> - Añade una entidad al sistema</li>
                                <li><code>removeEntityFromPhysics(entity)</code> - Remueve una entidad del sistema</li>
                                <li><code>setGravity(gravity)</code> - Configura la gravedad del mundo</li>
                                <li><code>getGravity()</code> - Obtiene la gravedad actual</li>
                            </ul>
                            <h3>Métodos privados:</h3>
                            <ul>
                                <li><code>updateAABBs(em, cm)</code> - Actualiza las AABBs de todas las entidades</li>
                                <li><code>detectCollisions(em, cm)</code> - Detecta colisiones entre entidades</li>
                                <li><code>resolveCollisions(em, cm)</code> - Resuelve las colisiones detectadas</li>
                                <li><code>applyVerletIntegration(entity, physics, transform, deltaTime)</code> - Aplica integración de Verlet</li>
                                <li><code>createAABBFromMesh(mesh, transform)</code> - Crea una AABB a partir de los vértices</li>
                                <li><code>triangleTriangleCollision(t1, t2, point, normal, depth)</code> - Detecta colisión entre triángulos</li>
                                <li><code>aabbCollision(box1, box2)</code> - Detecta colisión entre dos AABBs</li>
                                <li><code>extractTrianglesFromMesh(mesh, transform)</code> - Extrae triángulos de una malla</li>
                                <li><code>calculatePenetrationDepth(box1, box2)</code> - Calcula profundidad de penetración</li>
                                <li><code>calculateInertiaTensor(physics, mesh)</code> - Calcula tensor de inercia</li>
                                <li><code>alignToGround(physics, transform)</code> - Alinea objetos con el suelo</li>
                                <li><code>applyImpulseAtPoint(physics, impulse, point, centerOfMass)</code> - Aplica impulso en un punto</li>
                                <li><code>calculateWorldInertiaTensor(physics)</code> - Calcula tensor de inercia en espacio mundial</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <tr class="expandable-row" onclick="toggleDetails('renderSystem')">
                    <td>RenderSystem</td>
                    <td>Sistema de renderizado diferido con múltiples pasadas</td>
                </tr>
                <tr id="renderSystem" class="details-row">
                    <td colspan="2">
                        <div class="details-content">
                            <h3>Variables:</h3>
                            <ul>
                                <li><code>globalOutputTex</code> - Textura de salida global</li>
                                <li><code>textureType</code> - Tipo de textura a visualizar</li>
                                <li><code>screenMode</code> - Modo de visualización</li>
                                <li><code>skyboxSelector</code> - Selector de skybox activo</li>
                                <li><code>bSkybox</code> - Activa/desactiva skybox</li>
                                <li><code>bClouds</code> - Activa/desactiva nubes</li>
                                <li><code>samples</code> - Muestras para SSAO</li>
                                <li><code>offset</code> - Desplazamiento para SSAO</li>
                                <li><code>shadowStrength</code> - Intensidad de las sombras</li>
                                <li><code>cloudSettings</code> - Configuración de nubes volumétricas</li>
                                <li><code>gBuffer</code>, <code>gPosition</code>, <code>gNormal</code>, <code>gAlbedo</code> - Buffers para renderizado diferido</li>
                                <li><code>depthFBO</code>, <code>depthTexture</code> - Buffer y textura de profundidad</li>
                                <li><code>ssaoFBO</code>, <code>ssaoColorBuffer</code> - Framebuffer y color para SSAO</li>
                                <li><code>cloudFBO</code>, <code>cloudTexture</code> - Framebuffer y textura para nubes</li>
                            </ul>
                            <h3>Métodos:</h3>
                            <ul>
                                <li><code>RenderSystem(screenMode, windowWidth, windowHeight)</code> - Constructor</li>
                                <li><code>~RenderSystem()</code> - Destructor</li>
                                <li><code>render(em, cm, geometryShader, lightingShader, shadowShader, ssaoShader, ssaoShaderBlur, skyboxShader, cloudShader, skybox, camera)</code> - Renderiza la escena completa</li>
                                <li><code>createGBuffer(windowWidth, windowHeight)</code> - Crea el G-buffer</li>
                                <li><code>shadowPass(em, cm, shadowShader)</code> - Pasa de sombras</li>
                                <li><code>geometryPass(em, cm, shader, camera)</code> - Pasa de geometría</li>
                                <li><code>lightingPass(em, cm, lightingShader, camera)</code> - Pasa de iluminación</li>
                                <li><code>ssaoPass(ssaoShader, camera)</code> - Pasa de ambient occlusion</li>
                                <li><code>cloudPass(cloudShader, camera)</code> - Pasa de nubes volumétricas</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <tr class="expandable-row" onclick="toggleDetails('scriptComponent')">
                    <td>ScriptComponent</td>
                    <td>Componente para scripts Lua</td>
                </tr>
                <tr id="scriptComponent" class="details-row">
                    <td colspan="2">
                        <div class="details-content">
                            <h3>Variables:</h3>
                            <ul>
                                <li><code>state_</code> - Estado Lua encapsulado</li>
                                <li><code>s</code> - Puntero al estado Lua</li>
                                <li><code>scriptCode</code> - Código fuente del script</li>
                            </ul>
                            <h3>Métodos:</h3>
                            <ul>
                                <li><code>ScriptComponent(script)</code> - Constructor</li>
                                <li><code>loadScript(script)</code> - Carga script desde string</li>
                                <li><code>loadFile(filePath)</code> - Carga script desde archivo</li>
                                <li><code>run()</code> - Ejecuta el script</li>
                                <li><code>getGlobal&lt;T&gt;(name)</code> - Obtiene una variable global</li>
                                <li><code>check(error)</code> - Verifica errores de Lua</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <tr class="expandable-row" onclick="toggleDetails('scriptingSystem')">
                    <td>ScriptingSystem</td>
                    <td>Sistema para la gestión de scripts</td>
                </tr>
                <tr id="scriptingSystem" class="details-row">
                    <td colspan="2">
                        <div class="details-content">
                            <h3>Métodos:</h3>
                            <ul>
                                <li><code>ScriptingSystem()</code> - Constructor</li>
                                <li><code>~ScriptingSystem()</code> - Destructor</li>
                                <li><code>run(componentManager)</code> - Ejecuta todos los scripts</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <tr class="expandable-row" onclick="toggleDetails('shader')">
                    <td>Shader</td>
                    <td>Encapsula programas de sombreado GLSL</td>
                </tr>
                <tr id="shader" class="details-row">
                    <td colspan="2">
                        <div class="details-content">
                            <h3>Variables:</h3>
                            <ul>
                                <li><code>ID</code> - Identificador del programa shader en OpenGL</li>
                            </ul>
                            <h3>Métodos:</h3>
                            <ul>
                                <li><code>Shader(vertexPath, fragmentPath)</code> - Constructor para shaders básicos</li>
                                <li><code>Shader(vertexPath, fragmentPath, geometryPath)</code> - Constructor con shader de geometría</li>
                                <li><code>use()</code> - Activa este programa shader</li>
                                <li><code>setFloat(name, value)</code> - Establece un valor flotante uniforme</li>
                                <li><code>setInt(name, value)</code> - Establece un valor entero uniforme</li>
                                <li><code>setVec2(name, value)</code> - Establece un vector 2D uniforme</li>
                                <li><code>setVec3(name, value)</code> - Establece un vector 3D uniforme</li>
                                <li><code>setVec4(name, value)</code> - Establece un vector 4D uniforme</li>
                                <li><code>setMat4(name, mat)</code> - Establece una matriz 4x4 uniforme</li>
                                <li><code>checkCompileErrors(shader, type)</code> - Verifica errores de compilación</li>
                                <li><code>~Shader()</code> - Destructor</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <tr class="expandable-row" onclick="toggleDetails('skybox')">
                    <td>Skybox</td>
                    <td>Representa un cielo cubemap</td>
                </tr>
                <tr id="skybox" class="details-row">
                    <td colspan="2">
                        <div class="details-content">
                            <h3>Variables:</h3>
                            <ul>
                                <li><code>skyboxVAO</code>, <code>skyboxVBO</code> - Buffers para el cubo</li>
                                <li><code>cubemapTexture</code> - Textura del cubemap</li>
                            </ul>
                            <h3>Métodos:</h3>
                            <ul>
                                <li><code>Skybox()</code> - Constructor</li>
                                <li><code>~Skybox()</code> - Destructor</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <tr class="expandable-row" onclick="toggleDetails('skyboxManager')">
                    <td>SkyboxManager</td>
                    <td>Gestiona skyboxes para el fondo de escena</td>
                </tr>
                <tr id="skyboxManager" class="details-row">
                    <td colspan="2">
                        <div class="details-content">
                            <h3>Variables:</h3>
                            <ul>
                                <li><code>skyboxes</code> - Vector de skyboxes cargados</li>
                            </ul>
                            <h3>Métodos:</h3>
                            <ul>
                                <li><code>SkyboxManager()</code> - Constructor</li>
                                <li><code>add(faces)</code> - Añade un skybox desde 6 imágenes</li>
                                <li><code>loadCubemap(faces, skybox)</code> - Carga las 6 caras de un cubemap</li>
                                <li><code>render(skyboxShader, camera, skyboxSelected)</code> - Renderiza el skybox seleccionado</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <tr class="expandable-row" onclick="toggleDetails('soundSystem')">
                    <td>SoundSystem</td>
                    <td>Sistema de audio con OpenAL</td>
                </tr>
                <tr id="soundSystem" class="details-row">
                    <td colspan="2">
                        <div class="details-content">
                            <h3>Variables:</h3>
                            <ul>
                                <li><code>tracksForBranching</code> - Pistas para ramificación</li>
                                <li><code>tracksForInterpolateBranching</code> - Pistas para interpolación</li>
                                <li><code>branching</code> - Estructura de ramificación</li>
                                <li><code>device</code> - Dispositivo de audio OpenAL</li>
                                <li><code>context</code> - Contexto de audio OpenAL</li>
                                <li><code>buffers</code> - Buffers de audio</li>
                                <li><code>sources</code> - Fuentes de audio</li>
                            </ul>
                            <h3>Métodos:</h3>
                            <ul>
                                <li><code>SoundSystem()</code> - Constructor</li>
                                <li><code>~SoundSystem()</code> - Destructor</li>
                                <li><code>loadOggFile(filePath, buffer)</code> - Carga archivo Ogg Vorbis</li>
                                <li><code>loadWavFile(filePath, buffer)</code> - Carga archivo WAV</li>
                                <li><code>play(source)</code> - Reproduce una fuente de audio</li>
                                <li><code>pause(source)</code> - Pausa una fuente de audio</li>
                                <li><code>stop(source)</code> - Detiene una fuente de audio</li>
                                <li><code>setVolume(source, volume)</code> - Establece volumen</li>
                                <li><code>setLooping(source, loop)</code> - Establece repetición</li>
                                <li><code>crossfade(sourceFrom, sourceTo, crossfadeStart)</code> - Transición entre pistas</li>
                                <li><code>cleanup()</code> - Libera recursos de audio</li>
                                <li><code>addBufferToSourceQueue(source, buffer)</code> - Añade buffer a la cola</li>
                                <li><code>removeBufferToSourceQueue(source, buffer)</code> - Elimina buffer de la cola</li>
                                <li><code>removeAllBuffersQueue(source)</code> - Limpia la cola de buffers</li>
                                <li><code>getBuffersProccesed(source)</code> - Obtiene buffers procesados</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <tr class="expandable-row" onclick="toggleDetails('textureComponent')">
                    <td>TextureComponent</td>
                    <td>Gestiona texturas para materiales</td>
                </tr>
                <tr id="textureComponent" class="details-row">
                    <td colspan="2">
                        <div class="details-content">
                            <h3>Variables:</h3>
                            <ul>
                                <li><code>ID</code> - Identificador OpenGL de la textura</li>
                            </ul>
                            <h3>Métodos:</h3>
                            <ul>
                                <li><code>TextureComponent(image)</code> - Constructor con imagen</li>
                                <li><code>TextureComponent(image)</code> - Constructor con puntero compartido a imagen</li>
                                <li><code>loadTexture(path)</code> - Carga una textura desde archivo</li>
                                <li><code>bind(id, sampler, shader)</code> - Activa la textura para renderizado</li>
                                <li><code>convertToRGB(data, width, height, channels)</code> - Convierte datos de imagen a RGB</li>
                                <li><code>~TextureComponent()</code> - Destructor</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <tr class="expandable-row" onclick="toggleDetails('textureImage')">
                    <td>TextureImage</td>
                    <td>Almacena datos de una imagen de textura</td>
                </tr>
                <tr id="textureImage" class="details-row">
                    <td colspan="2">
                        <div class="details-content">
                            <h3>Variables:</h3>
                            <ul>
                                <li><code>data</code> - Datos de la imagen</li>
                                <li><code>width</code>, <code>height</code> - Dimensiones de la imagen</li>
                                <li><code>nrChannels</code> - Número de canales de color</li>
                            </ul>
                            <h3>Métodos:</h3>
                            <ul>
                                <li><code>TextureImage(data, width, height, nrChannels)</code> - Constructor</li>
                                <li><code>~TextureImage()</code> - Destructor</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <tr class="expandable-row" onclick="toggleDetails('transformComponent')">
                    <td>TransformComponent</td>
                    <td>Componente que define posición, rotación y escala</td>
                </tr>
                <tr id="transformComponent" class="details-row">
                    <td colspan="2">
                        <div class="details-content">
                            <h3>Variables:</h3>
                            <ul>
                                <li><code>position</code> - Vector de posición (x, y, z)</li>
                                <li><code>rotation</code> - Vector de rotación en grados (x, y, z)</li>
                                <li><code>scale</code> - Vector de escala (x, y, z)</li>
                                <li><code>verticalDirection</code> - Dirección vertical</li>
                                <li><code>horizontallDirection</code> - Dirección horizontal</li>
                            </ul>
                            <h3>Métodos:</h3>
                            <ul>
                                <li><code>TransformComponent(pos, rot, scl)</code> - Constructor</li>
                                <li><code>getTransformationMatrix()</code> - Obtiene la matriz de transformación</li>
                                <li><code>setPosition(newPos)</code> - Establece la posición</li>
                                <li><code>setRotation(newRot)</code> - Establece la rotación</li>
                                <li><code>setScale(newScale)</code> - Establece la escala</li>
                                <li><code>~TransformComponent()</code> - Destructor</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <tr class="expandable-row" onclick="toggleDetails('transformSystem')">
                    <td>TransformSystem</td>
                    <td>Sistema para la actualización de transformaciones</td>
                </tr>
                <tr id="transformSystem" class="details-row">
                    <td colspan="2">
                        <div class="details-content">
                            <h3>Métodos:</h3>
                            <ul>
                                <li><code>TransformSystem()</code> - Constructor</li>
                                <li><code>~TransformSystem()</code> - Destructor</li>
                                <li><code>update(em, componentManager, deltaTime)</code> - Actualiza todas las transformaciones</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <tr class="expandable-row" onclick="toggleDetails('triangle')">
                    <td>Triangle</td>
                    <td>Estructura para representar un triángulo en el espacio 3D</td>
                </tr>
                <tr id="triangle" class="details-row">
                    <td colspan="2">
                        <div class="details-content">
                            <h3>Variables:</h3>
                            <ul>
                                <li><code>v0, v1, v2</code> - Los tres vértices del triángulo</li>
                            </ul>
                            <h3>Métodos:</h3>
                            <ul>
                                <li><code>Triangle()</code> - Constructor por defecto</li>
                                <li><code>Triangle(v0, v1, v2)</code> - Constructor con los tres vértices</li>
                                <li><code>getNormal()</code> - Calcula la normal del triángulo</li>
                                <li><code>getAABB()</code> - Calcula la caja delimitadora del triángulo</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <tr class="expandable-row" onclick="toggleDetails('uiRenderer')">
                    <td>UIRenderer</td>
                    <td>Sistema de interfaz de usuario con ImGui</td>
                </tr>
                <tr id="uiRenderer" class="details-row">
                    <td colspan="2">
                        <div class="details-content">
                            <h3>Métodos:</h3>
                            <ul>
                                <li><code>UIRenderer(window)</code> - Constructor</li>
                                <li><code>newFrame()</code> - Inicia un nuevo frame de UI</li>
                                <li><code>endFrame()</code> - Finaliza y renderiza un frame de UI</li>
                                <li><code>entityViewer(em)</code> - Muestra entidades del sistema</li>
                                <li><code>changeRenderTexture(textureType, skybox, skyboxSelector, clouds)</code> - Cambia la textura de renderizado</li>
                                <li><code>ecsDemoInfo()</code> - Muestra información del sistema ECS</li>
                                <li><code>changeMeshDemoInfo()</code> - Muestra información de cambio de malla</li>
                                <li><code>TransformEditor(transform)</code> - Editor de componentes Transform</li>
                                <li><code>LightEditor(light)</code> - Editor de componentes Light</li>
                                <li><code>CameraEditor(camera)</code> - Editor de cámara</li>
                                <li><code>ColorEditor(color)</code> - Editor de componentes Color</li>
                                <li><code>ShadowEditor(renderSystem)</code> - Editor de sombras</li>
                                <li><code>CloudEditor(renderSystem)</code> - Editor de nubes</li>
                                <li><code>lightSelector(EntityManager& em, ComponentManager& cm)</code> - Selecciona la luz que deseas y te permite editarla</li>
                                <li><code>settingsWindow(camera, light, Deferred, textureType, skybox, skyboxSelector, clouds)</code> - Ventana de configuración</li>
                                <li><code>renderTextureWindow(textureID)</code> - Muestra una textura en ventana</li>
                                <li><code>renderWindow(system)</code> - Muestra ventana de renderizado</li>
                                <li><code>~UIRenderer()</code> - Destructor</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <tr class="expandable-row" onclick="toggleDetails('velocityComponent')">
                    <td>VelocityComponent</td>
                    <td>Componente para almacenar información de velocidad</td>
                </tr>
                <tr id="velocityComponent" class="details-row">
                    <td colspan="2">
                        <div class="details-content">
                            <h3>Variables:</h3>
                            <ul>
                                <li><code>value</code> - Valor de velocidad</li>
                            </ul>
                            <h3>Métodos:</h3>
                            <ul>
                                <li><code>VelocityComponent()</code> - Constructor por defecto (0.0)</li>
                                <li><code>VelocityComponent(v)</code> - Constructor con valor inicial</li>
                                <li><code>~VelocityComponent()</code> - Destructor</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <tr class="expandable-row" onclick="toggleDetails('window')">
                    <td>Window</td>
                    <td>Gestiona la ventana de aplicación</td>
                </tr>
                <tr id="window" class="details-row">
                    <td colspan="2">
                        <div class="details-content">
                            <h3>Variables:</h3>
                            <ul>
                                <li><code>window</code> - Puntero a la ventana GLFW</li>
                            </ul>
                            <h3>Métodos:</h3>
                            <ul>
                                <li><code>make(width, height, name, system)</code> - Crea una nueva ventana</li>
                                <li><code>Window(glfwWindow)</code> - Constructor</li>
                                <li><code>makeContext(system)</code> - Configura el contexto OpenGL</li>
                                <li><code>isOpen()</code> - Verifica si la ventana está abierta</li>
                                <li><code>clear(r, g, b, a)</code> - Limpia el buffer con un color</li>
                                <li><code>swapBuffers()</code> - Intercambia los buffers (doble buffer)</li>
                                <li><code>pollEvents()</code> - Procesa eventos pendientes</li>
                                <li><code>getWindow()</code> - Obtiene el puntero a la ventana GLFW</li>
                                <li><code>~Window()</code> - Destructor</li>
                            </ul>
                        </div>
                    </td>
                </tr>
            </table>
        </section>
        
        <section id="descargas">
            <h2>Instalación</h2>
                <div class="download-section">
                    <h3>Descargar OPEngine</h3>
                    <li>1º Ejecuta <strong>tools\gendeps.bat</strong> para generar las dependencias.</li>
                    <li>2º Ejecuta <strong>tools\genproject.bat</strong> para crear la solución de Visual Studio.</li>
                    <a href="OPEngine_0.2.zip" class="btn download-btn">
                        <i class="download-icon"></i>
                        Descargar OPEngine v0.2
                    </a>
                    <p class="download-info">Tamaño: 12 MB • Última actualización: 24 Abril 2025</p>
                </div>
        </section>
    </main>
    
    <footer>
        <div class="container">
            <p>&copy; 2025 OPEngine. Todos los derechos reservados para Rubén Gil Fabregat y Pau Badía Villanueva.</p>
        </div>
    </footer>
    
    <!-- Lightbox para las imágenes -->
    <div class="lightbox" id="imageLightbox">
        <div class="lightbox-content">
            <img src="" alt="" class="lightbox-image" id="lightboxImage">
            <div class="lightbox-caption" id="lightboxCaption"></div>
            <div class="lightbox-close">&times;</div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Script para los elementos desplegables
            var coll = document.getElementsByClassName("collapsible");
            for (var i = 0; i < coll.length; i++) {
                coll[i].addEventListener("click", function() {
                    this.classList.toggle("active");
                    var content = this.nextElementSibling;
                    if (content.style.maxHeight) {
                        content.style.maxHeight = null;
                    } else {
                        content.style.maxHeight = content.scrollHeight + "px";
                    }
                });
            }
            
            // Script para el lightbox de imágenes
            const galleryItems = document.querySelectorAll('.gallery-item');
            const lightbox = document.getElementById('imageLightbox');
            const lightboxImg = document.getElementById('lightboxImage');
            const lightboxCaption = document.getElementById('lightboxCaption');
            const closeBtn = document.querySelector('.lightbox-close');
            
            // Función para abrir el lightbox
            function openLightbox(src, alt, caption) {
                lightboxImg.src = src;
                lightboxImg.alt = alt;
                lightboxCaption.textContent = caption;
                lightbox.classList.add('active');
                document.body.style.overflow = 'hidden'; // Prevenir scroll
            }
            
            // Función para cerrar el lightbox
            function closeLightbox() {
                lightbox.classList.remove('active');
                setTimeout(() => {
                    lightboxImg.src = '';
                }, 300);
                document.body.style.overflow = ''; // Restaurar scroll
            }
            
            // Añadir eventos a las imágenes de la galería
            galleryItems.forEach(item => {
                item.addEventListener('click', function() {
                    const img = this.querySelector('img');
                    const caption = this.querySelector('.gallery-caption').textContent;
                    openLightbox(img.src, img.alt, caption);
                });
            });
            
            // Cerrar el lightbox al hacer clic en el botón de cerrar
            closeBtn.addEventListener('click', closeLightbox);
            
            // Cerrar el lightbox al hacer clic fuera de la imagen
            lightbox.addEventListener('click', function(e) {
                if (e.target === lightbox) {
                    closeLightbox();
                }
            });
            
            // Cerrar el lightbox con la tecla ESC
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && lightbox.classList.contains('active')) {
                    closeLightbox();
                }
            });
        });


/* Script JavaScript */
function toggleDetails(id) {
    const element = document.getElementById(id);
    // Encontrar la fila expandible que activó esta acción
    const expandableRow = document.querySelector(`[onclick="toggleDetails('${id}')"]`);
    
    if (element.style.display === "table-row") {
        // Ocultar detalles
        element.style.display = "none";
        // Quitar clase active de la fila expandible
        expandableRow.classList.remove("active");
    } else {
        // Mostrar detalles
        element.style.display = "table-row";
        // Añadir clase active a la fila expandible
        expandableRow.classList.add("active");
    }
}

// Inicializar todas las filas de detalles como ocultas
document.addEventListener('DOMContentLoaded', function() {
    const apiDetailsRows = document.querySelectorAll('.details-row');
    apiDetailsRows.forEach(function(row) {
        row.style.display = 'none';
    });
});

document.addEventListener('DOMContentLoaded', function() {
    const searchInput = document.getElementById('apiSearchInput');
    const clearButton = document.getElementById('apiSearchClear');
    const apiTable = document.querySelector('.api-table');
    const apiRows = apiTable.querySelectorAll('tr.expandable-row');
    
    // Crear elemento para mensaje de "sin resultados"
    const noResultsMessage = document.createElement('div');
    noResultsMessage.className = 'no-results-message';
    noResultsMessage.textContent = 'No se encontraron resultados para tu búsqueda.';
    apiTable.parentElement.insertBefore(noResultsMessage, apiTable.nextSibling);
    
    // Función para filtrar la tabla
    function filterApiTable() {
        const searchTerm = searchInput.value.toLowerCase().trim();
        let hasResults = false;
        
        // Mostrar/ocultar el botón de limpiar
        if (searchTerm === '') {
            clearButton.classList.add('hidden');
        } else {
            clearButton.classList.remove('hidden');
        }
        
        // Filtrar filas
        apiRows.forEach(row => {
            const classFunctionName = row.cells[0].textContent.toLowerCase();
            const description = row.cells[1].textContent.toLowerCase();
            const detailsId = row.getAttribute('onclick').match(/'(.*?)'/)[1];
            const detailsRow = document.getElementById(detailsId);
            
            if (classFunctionName.includes(searchTerm) || description.includes(searchTerm)) {
                row.classList.remove('hidden-row');
                
                // Destacar texto coincidente
                if (searchTerm !== '') {
                    highlightText(row.cells[0], searchTerm);
                    highlightText(row.cells[1], searchTerm);
                } else {
                    // Restaurar texto original sin resaltado
                    row.cells[0].innerHTML = row.cells[0].textContent;
                    row.cells[1].innerHTML = row.cells[1].textContent;
                }
                
                hasResults = true;
            } else {
                row.classList.add('hidden-row');
                // Ocultar detalles si la fila está oculta
                if (detailsRow) {
                    detailsRow.style.display = 'none';
                    row.classList.remove('active');
                }
            }
        });
        
        // Mostrar mensaje de "sin resultados" si es necesario
        if (!hasResults && searchTerm !== '') {
            noResultsMessage.style.display = 'block';
        } else {
            noResultsMessage.style.display = 'none';
        }
    }
    
    // Función para resaltar texto
    function highlightText(element, searchTerm) {
        const text = element.textContent;
        const regex = new RegExp(searchTerm, 'gi');
        element.innerHTML = text.replace(regex, match => 
            `<span class="api-search-highlight">${match}</span>`
        );
    }
    
    // Eventos
    searchInput.addEventListener('input', filterApiTable);
    
    clearButton.addEventListener('click', function() {
        searchInput.value = '';
        filterApiTable();
        searchInput.focus();
    });
    
    // Inicializar estado del botón limpiar
    clearButton.classList.add('hidden');
});
    </script>
</body>
</html>